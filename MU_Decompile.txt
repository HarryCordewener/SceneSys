
@@ Scene System
@create Scene System
@link Scene System = #2
@lock/Basic Scene System=Scene System
@lset Scene System/Basic=no_inherit
@lock/Command Scene System=FN`IS`RIGHTVERSION/1&FN`IS`SETUP/1
@lset Scene System/Command=no_inherit
@set Scene System = VISUAL
@set Scene System = WIZARD
@set Scene System = ORPHAN
@power Scene System = No_Pay
@power Scene System = SQL_OK
&ACONNECT Scene System=@@ This will run anything placed under the INCLUDE`CONNECT attribute tree. This way you can split things up if you want to keep things tidy - or want to have an easy time telling apart your own additions.                                                                                     ; @dolist lattr(me/include`connect`)=@include me/%il=%:
@set Scene System/ACONNECT=no_command prefixmatch
&CMDALIAS Scene System=Using the power of @include to show how easy it is to make a command alias.
&CMDALIAS`SCHEDULE Scene System=$^[@+-=!.~]?(?\:scenes|schedule|tp|tps)(?\:\s(.+))?$:@assert isnum(%1)=@include me/cmds`schedule ; @include me/cmds`schedule`view=,%1
@set Scene System/CMDALIAS`SCHEDULE=regexp
&CMDS Scene System=Contains the commands. This system is REGEXP rich - which means that, if you are intent on changing these, you had better know what you are doing.
&CMDS`ACTIVATE Scene System=$^[@+-=!.~]?scene(?\:/|\s+#)activate(?\:\s+(.+))?$:                                                                                   @@ Activates scene ## assuming that you are /in/ that scene, as dictated by the POSER table. If no scene is given, it will assume you are trying to activate the one you were in most recently.                                                                                                              Arguments= %1: Scene ID                                                                                                                                   ; th setq(SceneID,firstof( %1 , u(fn`get`scene`lastvalidactive, u(fn`get`playerid,%:) ) ))[@@(Puts the true scene into %q<SceneID>)]                                                                                     ; @assert u(fn`is`scene`id,%q<SceneID>)=                                       @pemit %#=u(fn`msg,nosuchscene,%q<SceneID>)                               ; @include me/include`activate=%q<SceneID>,%:,u(fn`get`playerid,%:),%:
@set Scene System/CMDS`ACTIVATE=regexp
&CMDS`ADDPLAYER Scene System=$^[@+-=!.~]?scene(?\:/|\s+#)addplayer(?\:\s+(.+?)(?\:=(.+))?)$:                                                                                          @@ This system adds a player to a scene, without checking for the locks.     Only available to staff and scene-owners.                                                                                                                 Arguments = %1: Player Ref, %2: Scene ID                                                                                                                  ; @assert setr(PlayerRef,objid(u(fn`locate,%1)))=                              @pemit %#=u(fn`msg,nosuchplayer,%q<PlayerRef>)                             ; @assert setr(PlayerID,u(fn`get`playerid,%q<PlayerRef>))=                     @pemit %#=u(fn`msg,nosuchplayerid,%q<PlayerID>)                                                                                                        ; th setq(SceneID,firstof(%2,u(fn`get`scene`recentatloc,objid(%l))))                                                                                      ; @assert or(u(fn`is`sceneowner,%q<SceneID>,%:),u(fn`is`staff,%:))=            @pemit %#=u(fn`msg,cannotaddtoscene,%q<SceneID>,%q<PlayerID>)             ; @include me/include`scene`addplayer=%q<SceneID>,%q<PlayerRef>,1,%:
@set Scene System/CMDS`ADDPLAYER=regexp
&CMDS`CONFIG Scene System=$^[@+-=!.~]?scene(?\:/|\s+#)config(?\:/view)?(?\:\s+([^=]+))?$:                                                                                          @@ This is the configuration system. It allows for different levels of access and displays configuration for the admin. Setting gets done in another system.                                                                                                                                           Arguments = %1: text                                                                                                                                     ; @assert %1=                                                                  @pemit %#=u(fn`display`config)[@@(No arguments? Simple table!)];                                                                                        ; @break u(fn`is`table,v(data`sql`table`config),%1)=                           @pemit %#=u(fn`display`config,%1)[@@(We have a table!)]                                                                                                 ; @break not(and(u(fn`is`scene`id,first(%1,/)),eq(words(%1),1)))=              @pemit %#=u(fn`msg,That wasn't a scene id nor a configuration setting.)                                                                                 ; @assert or(u(fn`is`table,v(data`sql`table`config),rest(%1,/)) ,                eq(strlen(rest(%1,/)),0)) =                                                @pemit %#=u(fn`msg,That is not a valid setting to display.)                                                                                             ; @pemit %#=u(fn`display`config,rest(%1,/),first(%1,/))[@@(We have a scene id!)]
@set Scene System/CMDS`CONFIG=regexp
&CMDS`CONFIG`SET Scene System=$^[@+-=!.~]?scene(?\:/|\s+#)(?\:config[/ ]?(?\:set)?|(?\:set)?[/ ]?config)\s+(?\:(.+?)/)?(.+?)=(.+)$:                                                                                              @@ This is the configuration setting system. Some funky stuff here. Let's see what asumptions we make, okay? %1 is always a scene. %2 is always the 'setting'. What it applies to when %1 is omitted: For admin, it means it is global. For sceneowner, it means 'activescene'. %3 is always 'what we set it to'. But we'll let include`config`set figure that out for us.                                                                                             ; @assert switch(strlen(%1),0,1,u(fn`is`scene`id,%1))=                         @pemit %#=u(fn`msg,Invalid Scene ID!)                                      ; @include me/include`configset=%1,%:,%2,%3
@set Scene System/CMDS`CONFIG`SET=regexp
&CMDS`CREATE Scene System=$(?s)^[@+-=!.~]?scene(?\:/|\s+#)(?\:create|start)(?\:\s+(.+))?$:                                                                                          @@ This is the command that gets run to create a scene. It will use a simple regexp to generate scene information, allowing the command-syntax to be user-friendly.                                                                                                                                            Arguments: %1 Creation Line                                                                                                                               ; @include me/include`create=firstof(%1,announce=no),%:
@set Scene System/CMDS`CREATE=regexp
&CMDS`DEACTIVATE Scene System=$^[@+-=!.~]?scene(?\:/|\s+#)deactivate(?\:\s+(.+))?$:                                                                              @@ De-activates the scene you are currently in. A staffer can force this on a player. Does not leave a scene!                                                                                                                         Arguments= %1: Player                                                                                                                                     ; @assert strlen(%1)=                                                          @include me/include`deactivate=u(fn`get`playerid,%:),%:,%:                                                                                              ; @assert u(fn`is`staff,%#)=                                                   @pemit %#=u(fn`msg,notstaff)                                                                                                                            ; @assert setr(PlayerID,u(fn`get`playerid,setr(PlayerDB,u(fn`locate,%1)))) =   @pemit %#=u(fn`msg,nosuchplayerid)                                                                                                                      ; @include me/include`deactivate=%q<PlayerID>,objid(%q<PlayerDB>),%:
@set Scene System/CMDS`DEACTIVATE=regexp
&CMDS`DESETUP Scene System=$^[@+-=!.~]?scene(?\:/|\s+#)desetup(?\:\s+(.+))$:                                                                                      @@ This is ran by an admin to remove a playerid, and thus making it so that any player that might have listened to that playerid, is no longer set up for SceneSys. It'll check if the playerid exists.                                                                                                         Arguments= %1: dbref/objid/name                                                                                                                           ; @assert u(fn`is`playerid,                                                            setr(PlayerID,firstof(u(fn`get`playerid,objid(pmatch(%1))),%1))) =   @pemit %#=u(fn`msg,playerid`not,%q<PlayerID>)                              ; @include me/include`player`desetup=%:,%q<PlayerID>
@set Scene System/CMDS`DESETUP=regexp
&CMDS`FINISH Scene System=$^[@+-=!.~]?scene(?\:/|\s+#)finish$:                                                                                       @@ This is ran by a player to set a scene they are currently in, as finished. They need to be the owner, or staff of course. It will then deactivate the scene for all players in it. ;                      @assert setr(SceneID,u(fn`get`activescene,u(fn`get`playerid,%:)))= @pemit %#=You are not in a scene. ;  @assert or(u(fn`is`sceneowner,%q<SceneID>,%:),u(fn`is`staff,%:))=@pemit %#=You don't own this scene. ; @inc me/include`configset=%q<SceneID>,%#,scene_state,3 ; @inc me/include`configset=%q<SceneID>,%#,scene_etime,u(fn`sql`timeformat) ; @pemit %#=Finished!
@set Scene System/CMDS`FINISH=regexp
&CMDS`FINISH_ALT Scene System=$^[@+-=!.~]?scene(?\:/|\s+#)finish(?\:\s+(\d+))$:                                                                                       @@ This is ran by a player to set a scene they indicate, as finished. They need to be the owner, or staff of course. It will then deactivate the scene for all players in it. ;                      @assert setr(SceneID,u(fn`is`scene`id,%1))= @pemit %#=We can't find that scene. ;  @assert or(u(fn`is`sceneowner,%q<SceneID>,%:),u(fn`is`staff,%:))=@pemit %#=You don't own that scene. ; @inc me/include`configset=%q<SceneID>,%#,scene_state,3 ; @inc me/include`configset=%q<SceneID>,%#,scene_etime,u(fn`sql`timeformat) ; @pemit %#=Finished!
@set Scene System/CMDS`FINISH_ALT=regexp
&CMDS`HELP Scene System=$^[@+-=!.~]?scene(?\:/|\s+#)h(?\:e(?\:lp?)?)?(?\:\s+(.+))?$:                                                                              @@ Built In Help System - for ease of use.                                   Arguments = %1: helpfile                                                                                                                                 ; @pemit %#=u(fn`display`help,firstof(%1,index))
@set Scene System/CMDS`HELP=regexp
&CMDS`INFO Scene System=$^[@+-=!.~]?scene(?\:(?\:(?\:/|\s+#)info)(?\:\s+([^#]+))?|(?\:\s+([^#]+)))$:                                                                                 @@ This is the scene-info command. It shows basic info, similar to the +scene/config/view command, but also shows important information.                                                                                            Arguments = %1: text                                                                                                                                          ; @assert setr(SceneID,u(fn`is`scene`id,                                                 firstof(%1,rest(%0),u(fn`get`activescene,u(fn`get`playerid,%:))))) =               @pemit %#=u(fn`msg,nosuchscene,%1)                                                                                                                           ; @pemit %#=u(fn`display`sceneinfo,%q<SceneID>)
@set Scene System/CMDS`INFO=regexp
&CMDS`INSTALL Scene System=$^[@+-=!.~]?scene(?\:(?\:/|\s+#)install)$: @nspemit %#=Installing (install script to be rewritten)
@set Scene System/CMDS`INSTALL=regexp
&CMDS`INSTALL`TRUNK Scene System=Contains the SceneSys listen. Remember to set your rooms LISTEN_PARENT!
@set Scene System/CMDS`INSTALL`TRUNK=regexp
&CMDS`JOIN Scene System=$^[@+-=!.~]?scene(?\:/|\s+#)join(?\:\s+(\d+))?$:                                                                                          @@ We will use a smart system to check if there was any recent activity in this room. If so, assume that is the scene to add them to. If an argument is given, add them to the given ScenID instead. You cannot join a FINISHED or UNFINISHED scene. Only 'paused' and 'activated' ones.                                                                                            Arguments = %1: Scene ID                                                                                                                                  ; th setq(SceneID,firstof(%1,u(fn`get`scene`recentatloc,objid(%l))))                                                                                     ; @assert u(fn`is`scene`id,%q<SCeneID>) =               @pemit %#=u(fn`msg,nosuchscene,%q<SceneId>) ; @assert u(fn`is`abletojoin,%q<SceneID>,%:)=                                  @pemit %#=u(fn`msg,cannotjoinscene,%q<SceneID>,%1)                         ; @include me/include`scene`addplayer=%q<SceneID>,%:,1,%:
@set Scene System/CMDS`JOIN=regexp
&CMDS`KICK Scene System=$^[@+-=!.~]?scene(?\:/|\s+#)kick(?\:\s+(.+?)(?\:=(.+))?)$:                                                                                @@ This system removes a player from a scene, without checking for the locks, and locks it against them. Only available to staff and scene-owners.                                                                               Arguments = %1: Player Ref, %2: Scene ID                                                                                                                  ; @assert setr(PlayerRef,objid(u(fn`locate,%1)))=                              @pemit %#=u(fn`msg,nosuchplayer,%q<PlayerRef>)                             ; @assert setr(PlayerID,u(fn`get`playerid,%q<PlayerRef>))=                     @pemit %#=u(fn`msg,nosuchplayerid,%q<PlayerID>)                                                                                                         ; th setq(SceneID,firstof(%2,u(fn`get`scene`recentatloc,objid(%l))))                                                                                      ; @assert or(u(fn`is`sceneowner,%q<SceneID>,%:),u(fn`is`staff,%:))=            @pemit %#=u(fn`msg,cannotremfromscene,%q<SceneID>,%q<PlayerRef>)           ; @include me/include`scene`remplayer=%q<SceneID>,%q<PlayerRef>,%:           ; @include me/include`lock`kickplayer=%q<SceneID>,%q<PlayerRef>,%:           ; @trig me/include`kick=%q<PlayerRef>,%q<SceneID>,%:
@set Scene System/CMDS`KICK=regexp
&CMDS`LEAVE Scene System=$^[@+-=!.~]?scene(?\:/|\s+#)leave(?\:\s+(.+))?$:                                                                                         @@ This will assume that when there is no argument, it is the 'active scene'. This command itself does no checking other than that.                                                                                          Arguments = %1: Scene ID                                                                                                                                  ; th setq(SceneID,firstof(%1,u(fn`get`activescene,u(fn`get`playerid,%:))))                                                                                ; @include me/include`leave=%q<SceneID>,%:,%:
@set Scene System/CMDS`LEAVE=regexp
&CMDS`LIST Scene System=$^[@+-=!.~]?scene(?\:/|\s+#)list(?\:\s(.+))?$:               @@ This command will somehow show a 'list' of scenes.                                                                                                     Arguments= %1: status                                                                                                                                     ; th setr(SceneState,firstof(edit(%1,*,all,?,all),v(data`defaultlist)))              [@@('active' as default)]                                              ; @assert lmatch(active unfinished paused finished all,%q<SceneState>)=            @pemit %#=u(fn`msg,invalidstatus,%1)                                                                                                                    ; @dol header [u(fn`get`list,u(fn`get`state`tonum,%q<SceneState>))] footer=       @pemit %#=u(fn`display`listitem,%il,%q<SceneState>)
@set Scene System/CMDS`LIST=regexp
&CMDS`MINE Scene System=$^[@+-=!.~]?scene(?\:(?\:/|\s+#)(?\:mine|my)?)?(?\:(?<=mine|my)\s+(.+))?$:                                                                     @@ This is the MyScene command. It shows pose-order, current unfinished scenes, most recent pose, what scene is active....                                                                                                     Arguments = %1: player (for staff only)                                                                                                                   ; @break and(strlen(%1),not(u(fn`is`staff,%#))) =                              @pemit %#=u(fn`msg,notstaff)                                                                                                                            ; @break and( strlen(%1) , not(u(fn`is`playerid,                                      setr(PlayerID,u(fn`get`playerid,objid(pmatch(%1))))))) =              @pemit %#=u(fn`msg,nosuchplayer,%q<PlayerID>)                                                                                                           ; @pemit %#=u(fn`display`myscene,firstof(%q<PlayerID>,                                   u(fn`get`playerid,%:)),firstof(objid(pmatch(%1)),%:))
@set Scene System/CMDS`MINE=regexp
&CMDS`MINE`FINISHED Scene System=$^[@+-=!.~]?scene(?\:(?\:/|\s+#)mine|my)(?\:(?\:/|\s+#)(?\:finish|finished)(?\:\s+(.+))?)$:                                                                     @@ This is the MyScene command. It shows pose-order, current finished scenes, most recent pose, what scene is active....                                                                                                     Arguments = %1: player (for staff only)                                                                                                                   ; @break and(strlen(%1),not(u(fn`is`staff,%#))) =                              @pemit %#=u(fn`msg,notstaff)                                                                                                                            ; @break and( strlen(%1) , not(u(fn`is`playerid,                                      setr(PlayerID,u(fn`get`playerid,objid(pmatch(%1))))))) =              @pemit %#=u(fn`msg,nosuchplayer,%q<PlayerID>)                                                                                                           ; @pemit %#=u(fn`display`myscene`top,setr(PlayerID,firstof(%q<PlayerID>,                                   u(fn`get`playerid,%:))),firstof(objid(pmatch(%1)),%:),finished); @dol/notify [u(fn`get`scene`playerparticipated,%q<PlayerID>,3)]=@pemit %#=u(fn`display`myscene`list,##,%q<PlayerID>) ; @wait me=@pemit %#=[u(fn`display`midline)]
@set Scene System/CMDS`MINE`FINISHED=regexp
&CMDS`MINE`UNFINISHED Scene System=$^[@+-=!.~]?scene(?\:(?\:/|\s+#)mine|my)(?\:(?\:/|\s+#)(?\:unfinish|unfinished)(?\:\s+(.+))?)$:                                                                     @@ This is the MyScene command. It shows pose-order, current finished scenes, most recent pose, what scene is active....                                                                                                     Arguments = %1: player (for staff only)                                                                                                                   ; @break and(strlen(%1),not(u(fn`is`staff,%#))) =                              @pemit %#=u(fn`msg,notstaff)                                                                                                                            ; @break and( strlen(%1) , not(u(fn`is`playerid,                                      setr(PlayerID,u(fn`get`playerid,objid(pmatch(%1))))))) =              @pemit %#=u(fn`msg,nosuchplayer,%q<PlayerID>)                                                                                                           ; @pemit %#=u(fn`display`myscene`top,setr(PlayerID,firstof(%q<PlayerID>,                                   u(fn`get`playerid,%:))),firstof(objid(pmatch(%1)),%:),finished); @dol/notify [u(fn`get`scene`playerparticipated,%q<PlayerID>,2)]=@pemit %#=u(fn`display`myscene`list,##,%q<PlayerID>) ; @wait me=@pemit %#=[u(fn`display`midline)]
@set Scene System/CMDS`MINE`UNFINISHED=regexp
&CMDS`MOVE Scene System=$^[@+-=!.~]?scene(?\:(?\:/|\s+#)move)\s+(?\:(\d+)/)?(\d+)=(?\:([^ 1234567890]+)\s*)?(\d+)?$:                                                                                                                                @@ Moves poses around. Up/Down or exchanging them out-right. Also can handle 'behind' and 'after'. This side figures out what those end up meaning.                                                                                    Arguments= %1: SceneId, %2: OldPose, %3: MoveID, %4: NewPose/Movecount                                                                                   ; @assert u(fn`is`scene`id,setr(SceneID,firstof(%1,u(fn`get`activescene,               u(fn`get`playerid,%:))))) =                                          @pemit %#=u(fn`msg,nosuchscene,%1)                                         ; @assert or(u(fn`is`staff,%:),u(fn`is`sceneowner,%:)) =                       @pemit u(fn`msg,notsceneowner,%q<SceneID>)                                 ; @assert and(strlen(%3),strlen(%4))=                                          @include me/include`pose`change_order=%:,%q<SceneID>,%2,%4                 ; th setr(Quantity,firstof(%4,1))                                            ; @switch/regexp %3 =                                                          \(up|\[+\]\) ,                                                                 { @include me/include`pose`move_order=%:,                                    %q<SceneID>,%2,[add(%2,%q<Quantity>)] }                                  , \(down|\[-\]\) ,                                                               { @include me/include`pose`move_order=%:,                                      %q<SceneID>,%2,[sub(%2,%q<Quantity>)] }                                , \(above|before\) ,                                                           { @include me/include`pose`move_order=%:,%q<SceneID>,%2,%4 }               , \(beneath|below|after\) ,                                                    { @include me/include`pose`move_order=%:,%q<SceneID>,%2,inc(%4) }          , @pemit %#=u(fn`msg,move`notsure)
@set Scene System/CMDS`MOVE=regexp
&CMDS`RECALL Scene System=$^[@+-=!.~]?scene(?\:/|\s+#)(?\:rec|reca|recal|recall|last)(?\:\s+(?\:(\d+)-)?(\d+)(?\:=(.+))?)?$:                                                                                                                                     @@ This is the scene recall command. It recalls poses from the scene as defined.                                                                                                                                                  Arguments= %1: Recall Min, %2: Recall Max, %3: Scene ID                                                                                                  ; @assert u(fn`is`scene`id,setr(SceneID,firstof(%3,u(fn`get`activescene,               u(fn`get`playerid,%:))))) =                                          @pemit %#=u(fn`msg,nosuchscene,%3)                                                                                                                      ; @include me/include`recall=%1,firstof(%2,u(data`defaultrecall),words(u(fn`get`playerid`allinscene,%q<SceneID>))),%q<SceneID>
@set Scene System/CMDS`RECALL=regexp
&CMDS`REDESC Scene System=$^[@+-=!.~]?scene(?\:/|\s+#)(?\:redescribe|redesc|desc|describe|description)(?\:\s+(.+?)(?\:=(.+))?)$:                                                                          @@ Sets the description of a scene. This is just a wrapper for +scene/config/set ID/scene_desc=SOMETHING.                                       Arguments= %1: ID, %2: Title                                       ; @inc me/cmds`config`set=%0,%1,scene_desc,%2
@set Scene System/CMDS`REDESC=regexp
&CMDS`REMPLAYER Scene System=$^[@+-=!.~]?scene(?\:/|\s+#)remplayer(?\:\s+(.+?)(?\:=(.+))?)$:                                                                                      @@ This system removes a player from a scene, without checking for the       locks. Only available to staff and scene-owners.                                                                                                          Arguments = %1: Player Ref, %2: Scene ID                                                                                                                  ; @assert setr(PlayerRef,objid(u(fn`locate,%1)))=                              @pemit %#=u(fn`msg,nosuchplayer,%q<PlayerRef>)                             ; @assert setr(PlayerID,u(fn`get`playerid,%q<PlayerRef>))=                     @pemit %#=u(fn`msg,nosuchplayerid,%q<PlayerID>)                                                                                                         ; th setq(SceneID,firstof(%2,u(fn`get`scene`recentatloc,objid(%l))))                                                                                     ; @assert or(u(fn`is`sceneowner,%q<SceneID>,%:),u(fn`is`staff,%:))=            @pemit %#=u(fn`msg,cannotremfromscene,%q<SceneID>,%q<PlayerRef>)                                                                                        ; @include me/include`scene`remplayer=%q<SceneID>,objid(%q<PlayerRef>),%:
@set Scene System/CMDS`REMPLAYER=regexp
&CMDS`RESETUP Scene System=$^[@+-=!.~]?scene(?\:/|\s+#)resetup(?\:\s+(.+))$:                                                                                      @@ This is ran by a staffer to resetup a player to use SceneSys! Will succeed even if they were already setup.                                                                                                                 Arguments= %1: dbref/objid/name                                                                                                                           ; @assert u(fn`is`playerid,setr(PlayerRef,                                             firstof(u(fn`get`playerid,objid(pmatch(%1))),%1))) =                 @pemit %#=u(fn`msg,playerid`not,%q<PlayerRef>)                                                                                                          ; @include me/include`player`resetup=%:,%q<PlayerRef>
@set Scene System/CMDS`RESETUP=regexp
&CMDS`RETITLE Scene System=$^[@+-=!.~]?scene(?\:/|\s+#)(?\:retitle|title|rename)(?\:\s+(.+?)(?\:=(.+))?)$:                                                                          @@ Sets the title of a scene. This is just a wrapper for +scene/config/set ID/scene_title=SOMETHING.                                       Arguments= %1: ID, %2: Title                                       ; @inc me/cmds`config`set=%0,%1,scene_title,%2
@set Scene System/CMDS`RETITLE=regexp
&CMDS`SCHEDULE Scene System=$^[@+-=!.~]?scene(?\:/|\s+#)(?\:schedule)(?\:\s(.+))?$:                                                                              @@ This is merely a command to display the current schedule of scenes. With an optional argument for selecting the 'stretch of time' in which to look for a schedule.                                                                                                                                           Arguments= %1: Timeline                                                                                                                                   ; @assert or(u(fn`is`valid`scheduletimeline,%1),not(strlen(%1)))=              @pemit %#=u(fn`msg,invalidscheduletimeline,%1)                             ; @include %!/include`schedule`view= %# ,                                                  setr(Days,firstof(u(fn`get`scheduletimeline,%1),                             u(fn`get`default`scheduletimeline))),                                        u(fn`get`scheduletimedays,%q<Days>)
@set Scene System/CMDS`SCHEDULE=regexp
&CMDS`SCHEDULE`ADD Scene System=$^[@+-=!.~]?scene(?\:/|\s+#)(?\:schedule)(?\:/|\s+#)(?\:add)(?\:\s(.+?))=((?s).+)$:                                                                                                                                                     @@ This command adds a scene to the schedule. I takes the time and title as the first argument, and the description as the second.                                                                                                    Arguments= %1: Time and Title, %2: Description                                                                                                            ; @assert u(fn`is`valid`schedulearg,%1)=                                       @pemit %#=u(fn`msg,Invalid Scheduling Argument)                            ; @break u(fn`has`scheduledscene,                                              setr(ScheduleData,u(fn`get`scheduleaddarg,%1)),%:) =                         @pemit %#=u(fn`msg,schedule`alreadyhavescenethatday)                       ; @include %!/include`schedule`add=                                            %:,u(fn`get`playerid,%:),%q<ScheduleData>,%2,u(fn`get`name,%:)
@set Scene System/CMDS`SCHEDULE`ADD=regexp
&CMDS`SCHEDULE`ADD_HERE Scene System=$^[@+-=!.~]?scene(?\:/|\s+#)(?\:schedule)(?\:/|\s+#)(?\:add/here)(?\:\s(.+?))=((?s).+)$:                                                                                                                                                     @@ This command adds a scene to the schedule with the room at the player's location. I takes the time and title as the first argument, and the description as the second.                                                                                                    Arguments= %1: Time and Title, %2: Description                                                                                                            ; @assert u(fn`is`valid`schedulearg,%1)=                                       @pemit %#=u(fn`msg,Invalid Scheduling Argument)                            ; @break u(fn`has`scheduledscene,                                              setr(ScheduleData,u(fn`get`scheduleaddarg,%1)),%:) =                         @pemit %#=u(fn`msg,schedule`alreadyhavescenethatday)                       ; @include %!/include`schedule`add=                                            %:,u(fn`get`playerid,%:),%q<ScheduleData>,%2,u(fn`get`name,%:),%l
@set Scene System/CMDS`SCHEDULE`ADD_HERE=regexp
&CMDS`SCHEDULE`DEL Scene System=$^[@+-=!.~]?scene(?\:/|\s+#)(?\:schedule)(?\:/|\s+#)(?\:del)(?\:\s(\d+))$:                                                                                @@ This command deletes a scene from the schedule.                                                                                                        Arguments= %1: Schedule ID                                                                                                                                ; @assert u(fn`is`valid`scheduleid,%1)=                                        @pemit %#=u(fn`msg,noscheduleid)                                           ; @assert or(strmatch(u(fn`get`playerid,%:),elements(                                  u(w`query,get`schedule`fullbyid::|,%1),6,|)),u(fn`is`staff,%:)) =    @pemit %#=u(fn`msg,dontownschedule)                                                                                                                     ; @include %!/include`schedule`del=%:,%1
@set Scene System/CMDS`SCHEDULE`DEL=regexp
&CMDS`SCHEDULE`RESCHEDULE Scene System=$^[@+-=!.~]?scene(?\:/|\s+#)(?\:schedule)(?\:/|\s+#)reschedule(?\:\s(\d+))=(.+)$:                                                                                                                                                       @@ This command reschedules a scene to a date, if all conditions are met.                                                                                 Arguments= %1: Schedule ID, %2: Date Argument                                                                                                             ; @assert u(fn`is`valid`scheduleid,%1)=                                        @pemit %#=u(fn`msg,noscheduleid)                                                                                                                        ; @assert or(strmatch(u(fn`get`playerid,%:),elements(                                  u(w`query,get`schedule`fullbyid::|,%1),6,|)),u(fn`is`staff,%:)) =    @pemit %#=u(fn`msg,dontownschedule)                                                                                                                     ; @assert or(u(fn`is`valid`scheduletimeline,%2),not(strlen(%2)))=              @pemit %#=u(fn`msg,invalidscheduletimeline,%2)                                                                                                          ; @include me/include`schedule`reschedule=%#,%1,%2
@set Scene System/CMDS`SCHEDULE`RESCHEDULE=regexp
&CMDS`SCHEDULE`VIEW Scene System=$^[@+-=!.~]?scene(?\:/|\s+#)(?\:schedule)(?\:/|\s+#)(?\:view)(?\:\s(\d+))$:                                                                               @@ This command simply displays the information on a scene.                  Arguments: %1=Schedule ID                                                    ; @assert u(fn`is`valid`scheduleid,%1)=                                        @pemit %#=u(fn`msg,noscheduleid)                                           ; @pemit %#=u(fn`display`schedule`info,%1)
@set Scene System/CMDS`SCHEDULE`VIEW=regexp
&CMDS`SETUP Scene System=$^[@+-=!.~]?scene(?\:/|\s+#)setup(?\:\s+(.+))?$:                                                                                        @@ This is ran by a player to setup themselves to use SceneSys! An admin can run this with an argument to set up a player or an object for SceneSys. It'll check if the argument exists, and that's it. If you accidentally add an 'exit' or 'room' and the system still has the defaults set - it will still not listen to it, but it will add the entry.                                                                                                    Arguments= %1: dbref/objid/name                                                                                                                          ; @assert [setr(PlayerRef,objid(u(fn`locate,firstof(%1,%#))))] =               @pemit %#=u(fn`msg,cantfind,%1)                                           ; @include me/include`player`setup=%:,%q<PlayerRef>
@set Scene System/CMDS`SETUP=regexp
&CMDS`UNDO_REDO Scene System=$^[@+-=!.~]?scene(?\:/|\s+#)(undo|redo|unpose|repose)$:                                                                               @@ Undoes or redoes a pose. In the case of 'undo', their last pose gets set 'ignore'. They cannot undo a pose before that -- and instead must pose again. Redo unsets a previous pose's ignore status. Only can be done if the last pose by that person was set 'ignore'. This assumes current active scene!                                                                                                                                                    Arguments= %1: undo/redo                                                                                                                                  ; @assert setr(SceneID,u(fn`get`activescene,                                           setr(PlayerID,u(fn`get`playerid,%:)))) =                             @pemit %#=u(fn`msg,noactivescene)                                                                                                                       ; @assert setr(LastPoseID,u(w`query,                                                   get`pose`latest`sceneplayer,%q<SceneID>,%q<PlayerID>)) =             @pemit %#=u(fn`msg,noposebyplayer)                                                                                                                      ; @switch %1=                                                                  re*                                                                          , {                                                                              @assert u(w`query,get`pose`ignore,%q<LastPoseID>) =                            @pemit %#=u(fn`msg,noundone)                                               ; @include me/include`pose`ignore = %:,%q<LastPoseID>,0                    } ,                                                                        un*                                                                          , {                                                                              @break u(w`query,get`pose`ignore,%q<LastPoseID>) =                             @pemit %#=u(fn`msg,undolimit,%q<LastPoseID>)                               ; @include me/include`pose`ignore =  %:,%q<LastPoseID>,1                   }
@set Scene System/CMDS`UNDO_REDO=regexp
&COMMAND_LOCK Scene System=Holds the response for failing to be setup and using a command.
@set Scene System/COMMAND_LOCK=no_command
&COMMAND_LOCK`FAILURE Scene System=if(u(fn`lock`testlock,fn`is`rightversion/1,%#),u(fn`msg,setup`needed,firstof(%0,%#)),u(fn`msg,badversion))
&CREDITS Scene System=All rights go to: Mercutio @ MUSH / Oathkeeper @ FinalKingdomMUSH. Email: admin@twilightdays.org -- +scene/help for help!                                                                              !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!                                          This code is best read using width: 78 using MUSHclient, made by a wiz #3-9. !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
&CREDITS`LOGO Scene System=____ ____ ____ _%b%b_ ____ ____ _%b%b%b_ ____ %r\[__%b%b|%b%b%b%b|___ |\\ | |___ \[__%b%b%b\\_/%b%b\[__%b%b%r___\] |___ |___ | \\| |___ ___\]%b%b%b|%b%b%b___\]
&DATA Scene System=Holds all data entries for the scene system.
@set Scene System/DATA=no_command
&DATA`ALWAYSTEL Scene System=1
&DATA`COMMAND_OVERRIDE Scene System=1[@@(SET ME TO 0 AFTER INSTALL, IF YOU DON'T LIKE THE COMMAND OVERRIDES AND WANNA FIGURE IT OUT YOURSELF; AND @SET its OVERRIDE attribute to NO_COMMAND )]
&DATA`DEFAULTLIST Scene System=active paused
&DATA`DEFAULTRECALL Scene System=@@(Set this to a value if you don't want the default amount of recall be 'as many players as have posed in a scene')
&DATA`GAMEPREFIX Scene System=+
@set Scene System=DATA`INSTALL:These are items that you need to set either on your database\, or on important PennMUSH files. getdate.template is required due to the expanded manners in which SceneSys will accept your 'date' format. Please overwrite your PennMUSH's getdate.template with what is found here. %r%rThe database.sql is the full format for SQL. We suggest you import this using PHPMYADMIN. If you do not know what PHPMYADMIN is... we suggest you look into this.%r%rThe items found on ANCESTOR should be set on your ancestor player. If you don't have an ancestor player... well... you should! See \(@\)config of ancestor_player.
@set Scene System/DATA`INSTALL=no_command
&DATA`INSTALL`ANCESTOR Scene System=@@ @TRIG this object's data`install`ancestor attribute to install onto the config(ancestor_player) object! - YES, THIS ATTRIBUTE! ; @dol lattr(me/data`install`ancestor`**)=@cpattr me/##=config(ancestor_player)/[edit(##,DATA`INSTALL`ANCESTOR`,)]
&DATA`INSTALL`ANCESTOR`EMITFORMAT Scene System=speak(&%3,|%4,says\,,SAY_FN,NONE_FN)
&DATA`INSTALL`ANCESTOR`LASTPOSE Scene System=Sets the Header and Footer items to default to 'true' or 'false' (1 or 0), around a pose. See include`lastpose`prepose and include`lastpose`postpose editing them. Or use the POSE/SAY/EMIT/SEMIPOSE-format attributes to prepend %7. We HIGHLY suggest at least one of these is activated in some way or another!
&DATA`INSTALL`ANCESTOR`LASTPOSE`POST Scene System=1
&DATA`INSTALL`ANCESTOR`LASTPOSE`PRE Scene System=1
&DATA`INSTALL`ANCESTOR`POSEFORMAT Scene System=speak(&%3,:%4,says\,,SAY_FN,NONE_FN)
&DATA`INSTALL`ANCESTOR`SAY_FN Scene System=ansi(default(%!/color`quote,+Gray),")[ansi(default(%!/color`speak,#EEEEEE),%0)][ansi(default(%!/color`quote,+Gray),")]
&DATA`INSTALL`ANCESTOR`SAYFORMAT Scene System=speak(&%3,"%4,says\,,SAY_FN,NONE_FN)
&DATA`INSTALL`ANCESTOR`SEMIPOSEFORMAT Scene System=speak(&%3,;%4,says\,,SAY_FN,NONE_FN)
&DATA`INSTALL`DATABASE.SQL Scene System=@@ @trigger this attribute in order to be given the SQL queries that create the tables in the scene/otherwise database. ; @dol lattr(#51/data`install`database.sql`)=@pemit %#=%r%r[v(##)]%r%r
@set Scene System/DATA`INSTALL`DATABASE.SQL=no_command
&DATA`INSTALL`DATABASE.SQL`SCENE_COMMENTS Scene System=CREATE TABLE IF NOT EXISTS `scene_comments` (  `comment_id` BIGINT(31) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT 'Designates the id number of the comment.',  `scene_id` BIGINT(31) UNSIGNED NOT NULL COMMENT 'Designates to what scene the comment belongs',  `pose_id` INT(11) DEFAULT NULL,  `player_id` BIGINT(31) UNSIGNED NOT NULL COMMENT 'Designates who added the comment.',  `Comment` text NOT NULL COMMENT 'The comment!',  PRIMARY KEY (`comment_id`)) ENGINE=MyISAM DEFAULT CHARSET=latin1 AUTO_INCREMENT=1 ;
&DATA`INSTALL`DATABASE.SQL`SCENE_CONFIG Scene System=CREATE TABLE IF NOT EXISTS `scene_config` (  `scene_id` BIGINT(31) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT 'Identifies the scene',  `timeout_skip` DOUBLE UNSIGNED NOT NULL DEFAULT '2400' COMMENT 'How long, in seconds, until we set a player as skip',  `timeout_pause` DOUBLE UNSIGNED NOT NULL DEFAULT '7200' COMMENT 'How long, in seconds, until we set a scene as paused',  `timeout_unfinished` DOUBLE UNSIGNED NOT NULL DEFAULT '604800' COMMENT 'How long, in seconds, until we set a scene as unfinished',  `scene_lock` VARCHAR(255) NOT NULL DEFAULT '#TRUE' COMMENT 'Identifies the lock of the scene, a player needs to pass',  `scene_title` VARCHAR(60) DEFAULT NULL COMMENT 'Identifies the title of the scene',  `scene_desc` longtext COMMENT 'Describes the scene in plain ascii',  `scene_players` text NOT NULL COMMENT 'Lists the players in the scene at the time of an update',  `scene_state` enum('0','1','2','3') NOT NULL DEFAULT '0' COMMENT 'Identifies the state of the scene. Finished (3), Unfinished (2), Paused (1) or Active (0)',  `scene_ordered` enum('0','1') NOT NULL DEFAULT '0' COMMENT 'Do we keep track of the playerorder? We do anyhow, but do we actually warn people that they posed out of turn?',  `scene_announce` VARCHAR(255) NOT NULL COMMENT 'Announce upon creation?',  `scene_private` enum('0','1') NOT NULL DEFAULT '0' COMMENT 'Is the scene private?', `spam_timer` SMALLINT(2) NOT NULL DEFAULT '4' COMMENT 'Keeps an integer value, for how many poses there can be per 10 seconds.',  `scene_owner` VARCHAR(255) NOT NULL COMMENT 'Identifies the scene''s owner.',  `scene_ctime` datetime NOT NULL COMMENT 'Shows when the scene was created.',  `scene_etime` datetime DEFAULT NULL COMMENT 'Indicates when the scene ended, or was set unfinished.',  PRIMARY KEY (`scene_id`),  KEY `timeout_away` (`timeout_skip`,`timeout_pause`,`timeout_unfinished`),  KEY `scene_state` (`scene_state`), FULLTEXT KEY `scene_title` (`scene_title`,`scene_desc`,`scene_players`)) ENGINE=MyISAM  DEFAULT CHARSET=latin1 AUTO_INCREMENT=1 ;
&DATA`INSTALL`DATABASE.SQL`SCENE_JOURNALS Scene System=CREATE TABLE IF NOT EXISTS `scene_journals` (  `journal_id` BIGINT(31) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT 'Identifies the journal.',  `player_id` BIGINT(31) NOT NULL COMMENT 'Identifies the poser_id who created the journal.',  `journal_time` datetime NOT NULL COMMENT 'Identifies when when the journal was created.',  `journal_title` VARCHAR(255) NOT NULL COMMENT 'Identifies the title of the journal.',  `journal_lock` VARCHAR(255) NOT NULL DEFAULT '#FALSE' COMMENT 'Identifies who can see the journal. ''#FALSE'' for ''only self''.',  `journal_text` longtext NOT NULL COMMENT 'Contains the contents of the journal.',  `journal_html` longtext NOT NULL COMMENT 'Contains the contents of the journal, in HTML format..',  PRIMARY KEY (`journal_id`)) ENGINE=MyISAM DEFAULT CHARSET=latin1 AUTO_INCREMENT=1 ;
&DATA`INSTALL`DATABASE.SQL`SCENE_PLAYERS Scene System=CREATE TABLE IF NOT EXISTS `scene_players` (  `player_id` BIGINT(31) NOT NULL AUTO_INCREMENT COMMENT 'Identifies the player',  `player_objid` VARCHAR(255) NOT NULL COMMENT 'Identifies the player''s object identity. DBREF:CSECS',  `player_initname` VARCHAR(255) NOT NULL DEFAULT 'Unset' COMMENT 'Designates the player''s initial name.',  `activescene_id` BIGINT(31) DEFAULT NULL COMMENT 'Identifies the scene the poser is active in. Empty if N/A.',  `scenecreate_announce` enum('0','1') NOT NULL DEFAULT '1' COMMENT 'Do they announce a scene starting by default if creating one?',  `bitlevel` enum('1','2','3') NOT NULL DEFAULT '1' COMMENT 'Designates the level of the player. ''1'' for player, ''2'' for ''staff'' and ''3'' for''headwizard''.',  `warnings` SET('newposewhileaway','scenefinish','outofroompose','inroompose') NOT NULL DEFAULT 'newposewhileaway,scenefinish,outofroompose,inroompose' COMMENT 'Indicates what warnings a user wants to listen to.',  `spammer` enum('0','1') NOT NULL DEFAULT '0' COMMENT 'Indicates whether or not someone is a spammer - thus locked from SceneSys.',  `setup` enum('0','1') NOT NULL DEFAULT '1' COMMENT 'Claims whether or not a player is setup for the system.',  PRIMARY KEY (`player_id`),  UNIQUE KEY `player_objid_2` (`player_objid`)) ENGINE=MyISAM  DEFAULT CHARSET=latin1 AUTO_INCREMENT=1 ;
&DATA`INSTALL`DATABASE.SQL`SCENE_POSERS Scene System=CREATE TABLE IF NOT EXISTS `scene_posers` (  `poser_playerid` VARCHAR(255) NOT NULL DEFAULT '#-1' COMMENT 'Identifies the poser in the scene',  `poser_away` enum('0','1') NOT NULL DEFAULT '0' COMMENT 'Identifies the poser as away',  `poser_skip` enum('0','1') NOT NULL DEFAULT '0' COMMENT 'Identifies the poser as to ''be skipped''',  `scene_id` BIGINT(20) UNSIGNED NOT NULL COMMENT 'Identifies the scene the poser is in',  `last_activity` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT 'Keeps track of when the player was last active in this scene.',  PRIMARY KEY (`poser_playerid`,`scene_id`)) ENGINE=MyISAM DEFAULT CHARSET=latin1;
&DATA`INSTALL`DATABASE.SQL`SCENE_POSES Scene System=CREATE TABLE IF NOT EXISTS `scene_poses` (  `pose_id` BIGINT(31) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT 'Identifies the pose uniquely',  `order_id` BIGINT(31) UNSIGNED DEFAULT '0' COMMENT 'Identifies the pose per scene',  `scene_id` BIGINT(31) UNSIGNED NOT NULL COMMENT 'Identifies the scene the pose belongs to',  `owner_id` BIGINT(31) UNSIGNED NOT NULL COMMENT 'Identifies the owner of the scene, at the time of the pose',  `poser_id` BIGINT(31) UNSIGNED NOT NULL DEFAULT '1' COMMENT 'Identifies the poser of the pose',  `poser_name` VARCHAR(255) CHARACTER SET latin1 NOT NULL COMMENT 'Name of character at the time of the pose',  `pose_time` datetime NOT NULL COMMENT 'The time at which the pose/message was created or last edited ',  `pose_penn` longtext CHARACTER SET latin1 COMMENT 'The body of the pose in ansi text',  `pose_room` VARCHAR(255) CHARACTER SET latin1 DEFAULT NULL COMMENT 'The database reference number of the room in which the pose was made',  `pose_room_name` VARCHAR(255) CHARACTER SET latin1 DEFAULT NULL COMMENT 'The name of the room the pose was made in at the time of the pose',  `ignore` enum('0','1') CHARACTER SET latin1 NOT NULL DEFAULT '0' COMMENT 'Do we ignore this pose?',  `sysevent` VARCHAR(255) CHARACTER SET latin1 DEFAULT NULL COMMENT 'Was there a system event? SYSEVENT | English representation.',  `comment` text CHARACTER SET latin1 COMMENT 'Comment on a pose or system event.',  PRIMARY KEY (`pose_id`),  UNIQUE KEY `COMPOSITE` (`scene_id`,`order_id`),  KEY `pose_id` (`pose_id`,`order_id`,`scene_id`),  FULLTEXT KEY `pose_penn` (`pose_penn`)) ENGINE=MyISAM  DEFAULT CHARSET=ascii COLLATE=ascii_bin AUTO_INCREMENT=1 ;
&DATA`INSTALL`DATABASE.SQL`SCENE_RELATIONSHIPS Scene System=CREATE TABLE IF NOT EXISTS `scene_relationships` (  `GLOBID` INT(11) NOT NULL AUTO_INCREMENT COMMENT 'The global id',  `RECURSEID` INT(11) DEFAULT NULL COMMENT 'Points at a global id - forming a relationship with it of being its child.',  `PLOTNAME` VARCHAR(255) DEFAULT NULL COMMENT 'Name of the plot',  `PLOTDESC` VARCHAR(255) DEFAULT NULL COMMENT 'Description of the plot',  `SCENEID` INT(11) DEFAULT NULL COMMENT 'The ID of the scene, if applicable.',  PRIMARY KEY (`GLOBID`)) ENGINE=MyISAM DEFAULT CHARSET=latin1 AUTO_INCREMENT=1 ;
&DATA`INSTALL`DATABASE.SQL`SCENE_SCHEDULE Scene System=CREATE TABLE IF NOT EXISTS `scene_schedule` (  `id` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT 'Schedule ID',  `time` datetime NOT NULL COMMENT 'Time and Day',  `title` VARCHAR(255) NOT NULL COMMENT 'Scene Title',  `description` text CHARACTER SET ascii COLLATE ascii_bin NOT NULL COMMENT 'Scene Description',  `room` VARCHAR(255) DEFAULT NULL COMMENT 'Room the scene is scheduled to take place in - optional.',  `player_id` BIGINT(31) NOT NULL COMMENT 'Who scheduled the scene',  `name` VARCHAR(255) NOT NULL,  PRIMARY KEY (`id`)) ENGINE=MyISAM  DEFAULT CHARSET=latin1 AUTO_INCREMENT=1 ;
&DATA`INSTALL`DATABASE.SQL`SCENE_TAGS Scene System=CREATE TABLE IF NOT EXISTS `scene_tags` (  `tag_id` BIGINT(31) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT 'Identifies the tag',  `poser_id` BIGINT(31) UNSIGNED NOT NULL DEFAULT '1' COMMENT 'Identifies the creator of the tag',  `scene_id` BIGINT(31) UNSIGNED NOT NULL COMMENT 'Identifies the scene the tag applies to',  `tag` VARCHAR(255) NOT NULL COMMENT 'Identifies the tag by a name',  PRIMARY KEY (`tag_id`),  UNIQUE KEY `TAG_TO_SCENE` (`tag_id`,`scene_id`),  FULLTEXT KEY `tag` (`tag`)) ENGINE=MyISAM DEFAULT CHARSET=latin1 AUTO_INCREMENT=1 ;
&DATA`INSTALL`DATABASE.SQL`SET Scene System=SET SQL_MODE="NO_AUTO_VALUE_ON_ZERO";
&DATA`INSTALL`GETDATE.TEMPLATE Scene System=@@ @trigger this attribute in order to be given the exact info you should put into your GETDATE.TEMPLATE ;   @pemit %#=%r%r[u(data`install`getdate.template`penn)]%r%r
@set Scene System/DATA`INSTALL`GETDATE.TEMPLATE=no_command
&DATA`INSTALL`GETDATE.TEMPLATE`PENN Scene System=\%a \%b \%d \%H:\%M:\%S \%Y%r\%a \%b \%d \%H:\%M:\%S%r\%b \%d \%H:\%M:\%S \%Y%r\%b \%d \%H:\%M:\%S%r\%B \%d \%H:\%M:\%S%r\%B \%d \%H:\%M:\%S \%Y%r\%a \%b \%d \%H:\%M \%Y%r\%a \%b \%d \%H:\%M%r\%b \%d \%H:\%M \%Y%r\%b \%d \%H:\%M%r\%B \%d \%H:\%M%r\%B \%d \%H:\%M \%Y%r\%b \%d \%Y%r\%b \%d%r\%B \%d \%Y%r\%B \%d%r\%Y-\%m-\%d \%H:\%M:\%S%r\%m \%d \%Y%r\%m \%d%r\%m \%d \%H:\%M \%Y%r\%m \%d \%H:\%M:\%S \%Y
&DATA`INSTALL`LANG Scene System=@@ @pemit %#=Ensure that you change the LANG in your 'restart' file to en_US!
&DATA`INSTALLED Scene System=0
&DATA`LISTENROOM Scene System=[pemit(%1,Please tell your staffer to set up scenesys properly. Point them to %!/LISTEN`SENDER and %!/DATA`LISTENROOM please. Thank you.)]#-1
&DATA`LISTENTO Scene System=PLAYER THING
&DATA`LISTENTO`COMMENT Scene System=What types do we listen to? Valid options: player thing exit room
&DATA`MAX Scene System=
&DATA`MAX`IDLETODEACTIVATE Scene System=8200
&DATA`MAXBUFFER Scene System=[div(strlen(repeat(-,100000)),2)][@@(This is a bit funky\, and requires knowledge of how PennMUSH works with its command buffer\, and function buffer. Leave this alone. DATA`MAXBUFFER when evaluated is the command-buffer! A buffer should /never/ be an uneven number.)]
&DATA`MAXSMARTSECS Scene System=2851200
&DATA`MINIMUMVERSION Scene System=1.8.5 patchlevel 4
&DATA`MINPOSEWORDS Scene System=10
&DATA`MINPOSEWORDS`COMMENT Scene System=How many words should be in a capture by the SceneSys's listen to asume it is a pose? This is to remove movement chatter - which is extremely hard to ignore.
&DATA`MINSMARTSECS Scene System=1200
&DATA`MSGPREFIX Scene System=\[[ansi(hw,SceneSys)]\]
&DATA`MYSCENECOUNT Scene System=5
&DATA`RECENTSCENESECS Scene System=21000
&DATA`SCANINTERVAL Scene System=5
&DATA`SCANINTERVAL`COMMENT Scene System=Per how many seconds do we do an entire system's check? This is for the main loop.
&DATA`SCHEDULEBOARD Scene System=2
&DATA`SCHEDULEBOARD_DB Scene System=#47
&DATA`SCHEDULEDEFAULT Scene System=10[@@(Amount of days go here.)]
&DATA`SQL Scene System=Holds the constant SQL information for this system. On a default install, stay off of these!
&DATA`SQL`DATABASE Scene System=scene
&DATA`SQL`TABLE Scene System=Contains the sql tables.
&DATA`SQL`TABLE`COMMENTS Scene System=scene_comments
&DATA`SQL`TABLE`COMMENTS`COMMENT Scene System=Contains scene-comments for poses, or scenes in general.
&DATA`SQL`TABLE`CONFIG Scene System=scene_config
&DATA`SQL`TABLE`CONFIG`COMMENT Scene System=Per scene configuration and resulting information, such as title and lock.
&DATA`SQL`TABLE`JOURNALS Scene System=scene_journals
&DATA`SQL`TABLE`JOURNALS`COMMENT Scene System=Contains player journals.
&DATA`SQL`TABLE`PLAYERS Scene System=scene_players
&DATA`SQL`TABLE`PLAYERS`COMMENT Scene System=Players && Scene table. What players are in what scenes, and what is their status in that scene?
&DATA`SQL`TABLE`POSER Scene System=scene_posers
&DATA`SQL`TABLE`POSER`COMMENT Scene System=Information about a poser. Holds OBJID information.
&DATA`SQL`TABLE`POSES Scene System=scene_poses
&DATA`SQL`TABLE`POSES`COMMENT Scene System=Holds all the poses for scenes, as well as who posed it as per 'poser'. Also allows for system messages and pose-comments.
&DATA`SQL`TABLE`RELATIONSHIPS Scene System=scene_relationships
&DATA`SQL`TABLE`RELATIONSHIPS`COMMENT Scene System=Contains a recursive relationship of scene-to-plot and plot-to-plot.
&DATA`SQL`TABLE`SCHEDULE Scene System=scene_schedule
&DATA`SQL`TABLE`SCHEDULE`COMMENT Scene System=Contains the scheduling information for scenes.
&DATA`SQL`TABLE`TAGS Scene System=scene_tags
&DATA`SQL`TABLE`TAGS`COMMENT Scene System=Holds tags, and displays what scenes they apply to, and who added the tag for /that/ scene.
&DATA`TELCOMMAND Scene System=+tel/loc
&DATA`URL Scene System=This contains your website's information. It is important to edit this!
&DATA`URL`BASE Scene System=finalkingdom.net/scene/
&DATA`URL`VIEW Scene System=view.php?id=
&DATA`URL`WIKIVIEW Scene System=view_wiki.php?id=
&DATA`USINGMEDIAWIKI Scene System=1
&DESCRIBE Scene System=u(credits`logo)%r%r%r[v(credits)]
@set Scene System/DESCRIBE=no_command visual prefixmatch public nearby
&FN Scene System=Holds all the SceneSys functions.
@set Scene System/FN=no_command
&FN`DISPLAY Scene System=Holds the SceneSys functions that deal with displaying information.
&FN`DISPLAY`CMDTAG Scene System=switch(config(pueblo),Yes,tagwrap(a xch_cmd="%0",strfirstof(%1,%0)),%1)
&FN`DISPLAY`CONFIG Scene System=u(fn`display`header,%bConfig[condall(%0,: %0,%1,%b-%bScene %1)]%b)%r[setq(Border,ansi(hb,|))][iter(Setting:~[if(%1,Setting,Default)]:~Explanation:|[u(fn`get`config,%0,%1)],align(20 1. 24 1. [sub(width(%#),50)],first(%i0,~),%q<Border>,switch(first(rest(%i0,~),~),?*,if(strmatch(rest(rest(%i0,~),~),*second*),#$ ([timestring(#$)]),#$),NULL),%q<Border>,rest(rest(%i0,~),~)),|,%r[u(fn`display`midline)]%r)]%r[u(fn`display`footer)]
&FN`DISPLAY`FOOTER Scene System=firstof([footer(%0,%1,%2)],center(\[%0\],78,-))
&FN`DISPLAY`HEADER Scene System=firstof([header(%0,%1,%2[@@(Sent to - if not %#)])],center(\[%0\],78,-))
&FN`DISPLAY`HEADER`LIST Scene System=ID: %b%b[ljust(Title,sub(width(%#),57))] Owner[space(11)]Start Date:%b%b%bEnd Date:%b%b%bOrdered:
&FN`DISPLAY`HELP Scene System=switch(%0,index,u(fn`display`help`table,u(fn`get`help`validoptions)),*,if(u(fn`is`helptopic,%0),u(fn`display`help`topic,%0),u(fn`msg,nohelpfile,%0)))
&FN`DISPLAY`HELP`TABLE Scene System=u(fn`display`header,\[ SCENESYS: HELP MENU \])%r[table(iter(%0,[after(%i0,MSG`HELP`)]),18,width(%#))]%r[u(fn`display`footer)]
&FN`DISPLAY`HELP`TOPIC Scene System=u(fn`display`header,\[ SCENESYS: HELP: %0 \])%r[u(msg`help`[edit(%0,%b,_)])]%r[u(fn`display`footer)]
&FN`DISPLAY`LISTITEM Scene System=switch(%0,header,u(fn`display`header,< [ansi(hw,Listing [lcstr(itemize(%1))] scenes)] >)%r[u(fn`display`header`list)],footer,u(fn`display`footer),u(fn`display`listitem`item,%0))
&FN`DISPLAY`LISTITEM`ITEM Scene System=setq(SceneInfo,u(w`query,get`scene`listinfo::|,%0))[align(5 [setr(Width,sub(width(%#),57))] 15 13 11 3,ansi([switch(%q<SceneInfo>,*|0,hg,*|1,hy,*|2,u,*|3,hw,n)],%0),left(firstof(first(%q<SceneInfo>,|),None),%q<Width>),left(u(fn`get`playername`from`playerid,extract(%q<SceneInfo>,2,1,|)),15),first(extract(%q<SceneInfo>,3,1,|)),switch(first(extract(%q<SceneInfo>,4,1,|)),0000-00-00,Unfinished,firstof(#$,Unfinished)),switch(extract(%q<SceneInfo>,5,1,|),0,No,1,Yes,?))]
&FN`DISPLAY`MIDLINE Scene System=firstof([midline(%0,%1,%2)],[footer(%0,%1,%2)],center(\[%0\],78,-))
&FN`DISPLAY`MYSCENE Scene System=[u(fn`display`header,< MyScene: [ansi(hw,name(%1))] >)]%r[align([sub(div(width(%#),2),4)] 2 [sub(div(width(%#),2),4)],ansi(hw,Active Scene): [switch(u(fn`get`activescene,%0),?*,u(fn`display`cmdtag,+scene #$,ansi(hru,##$)),ansi(hr,None))],,Has been in [ansi(hw,words(u(fn`get`scene`playerparticipated,%0,3[@@(complete)])))] completed scenes.)]%r[u(fn`display`midline,< [ansi(hw,Scenes current open and part of)] >)]%r[iter(u(fn`get`scene`playerparticipated,%0,if(%2,3[@@(complete)],1[@@(paused)] 0[@@(active)])),u(fn`display`myscene`list,%i0,%0),,%r[u(fn`display`midline)]%r)]%r[u(fn`display`footer,%bFor help: [ansi(hw,+scene/help)][if(u(fn`get`scene`playerparticipated,%0,2),%b- [u(fn`display`cmdtag,+scene/mine/unfinished)] for unfinished scenes)]%b)]
&FN`DISPLAY`MYSCENE`LIST Scene System=align(5 [sub(width(%#),6)],u(fn`display`cmdtag,scene/activate %0,#%0),u(fn`display`cmdtag,scene/info %0,[left(ljust(firstof(u(fn`get`config`tables,scene_title,%0),No Title.),sub(width(%#),43)),sub(width(%#),43))]) [ansi(hw,Your last pose)]: [strfirstof(u(w`query,get`pose`info,pose_time,u(w`query,get`pose`id`last`from`player_id_and_scene,%1,%0)),None Yet)]%r[ansi(hw,Status)]: [setr(SceneStatus,u(fn`get`scene`status,%0))] and [switch(u(fn`is`scene`ordered,%0),1,enforces pose-order.,switch(%q<SceneStatus>,Finished,did,does) not enforce pose-order.)])
&FN`DISPLAY`MYSCENE`TOP Scene System=[u(fn`display`header,< MyScene: [ansi(hw,name(%1))] >)]%r[align([sub(div(width(%#),2),4)] 2 [sub(div(width(%#),2),4)],ansi(hw,Active Scene): [switch(u(fn`get`activescene,%0),?*,u(fn`display`cmdtag,+scene #$,ansi(hru,##$)),ansi(hr,None))],,Has been in [ansi(hw,words(u(fn`get`scene`playerparticipated,%0,3[@@(complete)])))] completed scenes.)]%r[u(fn`display`midline,< [ansi(hw,Scenes current open and part of)] >)]
&FN`DISPLAY`PLAYERINFO Scene System=u(fn`display`header,< My Info: [ansi(hw,u(fn`get`playername`from`playerid,%0) (%0))] >)%r%r[u(fn`display`footer)]
&FN`DISPLAY`POSEORDER Scene System=>> DISPLAY POSE ORDER: %0 is the scene <<
&FN`DISPLAY`RECALLPOSE Scene System=u(fn`display`header,%b[ansi(hw,In '[first(u(w`query,get`pose`tableinfo,pose_room_name,%0),-)]'\, [u(w`query,get`pose`tableinfo,poser_name,%0)] posed)]: \( OrderID: #[u(w`query,get`pose`tableinfo,order_id,%0)] [null(ansi(hw,(PoseID: %0) \[[u(w`query,get`pose`tableinfo,pose_time,%0)]\]))]\)%b)%r[u(w`query,get`pose`tableinfo,pose_penn,%0)][switch(%1,%2,%r[u(fn`display`footer)],)]
&FN`DISPLAY`ROOMSCENE Scene System=localize(if( setr(SceneList,u(fn`get`scene`recentatloc,objid(%0),1)) , < [ansi(hg,ACTIVE SCENE[switch(words(%q<SceneList>),>1,S)])]: [itemize(iter(%q<SceneList>,[u(fn`display`cmdtag,+scene %i0,%i0)]))] > ))
@set Scene System/FN`DISPLAY`ROOMSCENE=visual public
&FN`DISPLAY`SCEDULE Scene System=
&FN`DISPLAY`SCEDULE`SCENE Scene System=
&FN`DISPLAY`SCEDULE`SCENE`TZ Scene System=elements(%q<FullInfo>,2,|)||
&FN`DISPLAY`SCENEINFO Scene System=u(fn`display`header,< Sceneinfo: [ansi(hw,Scene #%0)] >)%r[iter(scene_ctime:Creation_date scene_title:Title scene_desc:Description timeout_skip:Time_until_order_skip timeout_pause:Time_until_the_scene_is_paused timeout_unfinished:Time_until_the_scene_is_set_as_unfinished,ansi(hw,rest(edit(%i0,_,%b),:)):%b[firstof(reswitch([u(fn`get`config`tables,first(%i0,:),%0)],^\\d+$,timestring(#$),#$),Not Set.)]%r[u(fn`display`midline)],,%r)]%r[u(fn`display`sceneinfo`playersinscene,%0, [u(fn`get`config`tables,first(scene_owner,:),%0)]  )]%r[rjust(ansi(hw,Total poses):%b,sub(width(%#),8))]%b[center(u(w`query,get`pose`count`inscene,%0),7)]%r[u(fn`display`midline)]%r[ansi(hw,Status)]: [setr(SceneStatus,u(fn`get`scene`status,%0))] and [switch(u(fn`is`scene`ordered,%0),1,enforces pose-order.,switch(%q<SceneStatus>,Finished,did,does) not enforce pose-order.)]%r[u(fn`display`midline)]%r[ansi(hw,URL)]: [if(pueblo(%#),tag(a))]http://[v(data`url`base)][v(data`url`view)]%0[if(pueblo(%#),endtag(a))]%r[u(fn`display`footer)]
&FN`DISPLAY`SCENEINFO`PLAYERSINSCENE Scene System=align(20 [sub(width(%#),39)] 9 7,ansi(hw,Players):,ansi(hw,As):,ansi(hw,Status):,ansi(hw,Poses):)%r[if(setr(PlayerIDsInScene,setunion(u(fn`get`playerid`allinscene,%0),u(fn`get`playerid`allinposes,%0))),iter(%q<PlayerIDsInScene>,align(20 [sub(width(%#),39)] 9 -7,first(setr(PlayerPoses,firstof(ansi(switch(%1,%i0,gu,),u(fn`get`playername`posesinscene,%0,%i0,:|)),ansi(switch(%1,%i0,gu,),[u(fn`get`playername`from`playerid,%i0)]) )),|),firstof(itemize(rest(%q<PlayerPoses>,|),|),Themselves),u(fn`display`sceneinfo`playersinscene`status,%i0,%0),u(w`query,get`pose`count`inscene`fromplayer,%i0,%0)),,%r),u(fn`get`playername`from`playerid,u(fn`get`config`tables,scene_owner,%0)))]
&FN`DISPLAY`SCENEINFO`PLAYERSINSCENE`STATUS Scene System=switch(u(fn`is`inscene,%0,%1):[isdbref(u(fn`get`playerobjid,%0))]:[u(fn`lock`testlock,u(fn`get`scene`lock,%1),u(fn`get`playerobjid,%0))],*:0:*,Retired,0:1:1,Left,0:1:0,Kicked,1:*:1,[switch(u(fn`get`player`status`inscene,%0,%1),1,Skip,0,Active,ERROR! >[stext(0)]<)],ERROR! >[stext(0)]<)
&FN`DISPLAY`SCHEDULE Scene System=u(fn`display`header,< Current Schedule >)%r[setq(Start,first(%0,|))][map(fn`display`schedule`day,lnum(u(fn`get`scheduletimedays,%0)),,%r)]%r[u(fn`display`footer)]
&FN`DISPLAY`SCHEDULE`DAY Scene System=[setq(Day,convsecs(add(convtime(%1),mul(%0, stringsecs(1d) ))))][setq(ScheduleList,u(w`query,get`schedule`ids,u(fn`sql`timeformat,convtime(replace(%q<Day>,4,00:00:00))),u(fn`sql`timeformat,convtime(replace(%q<Day>,4,23:59:59)))))][u(fn`display`midline,< [ansi(hc,elements(%q<Day>,1 2 3 5))][if(strlen(%q<ScheduleList>),: [switch(words(%q<ScheduleList>),1,#$ scene,#$ scenes)],: None)] >)][map(fn`display`schedule`scene,%q<ScheduleList>,,)]
&FN`DISPLAY`SCHEDULE`INFO Scene System=setq(FullInfo,u(w`query,get`schedule`fullbyid::|,%0))[u(fn`display`header,< [ansi(hw,Schedule ID: %0)] - [first(extract(%q<FullInfo>,2,1,|))] >)]%r[align(34 -8 [config(player_name_len)] >[sub(width(%#),8,add(34,config(player_name_len),3))],u(%=`title),u(%=`time),u(%=`player),u(%=`room))][if(strlen(elements(%q<FullInfo>,5,|)),%r[u(fn`display`header)]%r[center(In [ansi(hw,name(elements(%q<FullInfo>,5,|)))],78)])]%r[u(fn`display`midline,< [ansi(hw,Description)] >)]%r[extract(%q<FullInfo>,4,1,|)]%r[u(fn`display`midline,< In Other Timezones >)]%r[lalign(-25 -25 -25,iter(EST Personal GMT, %i0%r[switch( [timefmt($a $H:$M ($I:$M $p),convtime([extract(%q<FullInfo>,2,1,|)]),switch(%i0,Personal,get(%#/TZ),EST,America/New_York,%i0) )], #-1*,No TZ Attribute Set,#$ )] ,,|),|)]%r[u(fn`display`footer)]
&FN`DISPLAY`SCHEDULE`INFO`PLAYER Scene System=firstof([name(u(fn`get`playerobjid,elements(%q<FullInfo>,6,|)))],[u(fn`get`playername`from`playerid,elements(%q<FullInfo>,6,|))])
&FN`DISPLAY`SCHEDULE`INFO`ROOM Scene System=if(strlen(elements(%q<FullInfo>,5,|)),u(fn`tel,elements(%q<FullInfo>,5,|),No Room Set)
&FN`DISPLAY`SCHEDULE`INFO`TIME Scene System=extract(last(elements(%q<FullInfo>,2,|)),1,2,:)
&FN`DISPLAY`SCHEDULE`INFO`TITLE Scene System=elements(%q<FullInfo>,3,|)
&FN`DISPLAY`SCHEDULE`SCENE Scene System=%r[setq(FullInfo,u(w`query,get`schedule`fullbyid::|,%0))][align(4 30 -8 [config(player_name_len)] >[sub(width(%#),8,add(4,30,config(player_name_len),4))],u(%=`id),u(%=`title),u(%=`time),u(%=`player),u(%=`tz))]
&FN`DISPLAY`SCHEDULE`SCENE`ID Scene System=u(fn`display`cmdtag,+scene/schedule/view [first(%q<FullInfo>,|)],first(%q<FullInfo>,|))
&FN`DISPLAY`SCHEDULE`SCENE`PLAYER Scene System=firstof([name(u(fn`get`playerobjid,elements(%q<FullInfo>,6,|)))],[u(fn`get`playername`from`playerid,elements(%q<FullInfo>,6,|))])
&FN`DISPLAY`SCHEDULE`SCENE`ROOM Scene System=if(strlen(elements(%q<FullInfo>,5,|)),u(fn`tel,elements(%q<FullInfo>,5,|),No Room Set)
&FN`DISPLAY`SCHEDULE`SCENE`TIME Scene System=extract(last(elements(%q<FullInfo>,2,|)),1,2,:)
&FN`DISPLAY`SCHEDULE`SCENE`TITLE Scene System=elements(%q<FullInfo>,3,|)
&FN`DISPLAY`SCHEDULE`SCENE`TZ Scene System=firstof(timefmt($I:$M $p $Z,convtime(elements(%q<FullInfo>,2,|)),get(%#/TZ)),No TZ Attr. Set)
&FN`EXITPAIR Scene System=filter(#lambda/match(home(\%0),loc(%0)),entrances(home(%0)))[@@(Takes an exit(out)\, goes out and will check what exit(in) goes back to the room exit(out) is in.)]
&FN`FILTER Scene System=Holds the SceneSys functions that filter out (relevant) information.
&FN`FILTER`CREATIONLINEDOUBLES Scene System=regeditall(%0,(\\xa0|^)(\[^\\xa0\]+:)(\[^\\xa0\]*)(?=.*\\2),,^\\xa0+|\\xa0+$,)
&FN`FILTER`CREATIONLINEDOUBLES`CREDIT Scene System=Credit for this filter goes to Walker@M*U*S*H - always fun to brainstorm over how to do these things. So many solutions to the same problem... See --> http://community.pennmush.org/blog/mercutio/2010/one-problem-many-solutions <--
&FN`FILTER`CREATIONLINEERRORS Scene System=[regeditall(%0,v(fn`is`validcreationline`regexp),)]
&FN`GET Scene System=Holds the SceneSys functions that deal in retrieving pure information. A lot of these are self-explainatory by name. In future versions, the 'expected input' may be added under the COMMENT substructure. (WIP)
&FN`GET`ACTIVESCENE Scene System=u(w`query,get`activescene,%0)
&FN`GET`BBPOST Scene System=element(get(v(data`scheduleboard_db)/mess_lst),after(grep(v(data`scheduleboard_db),HDR*,Schedule #%0:),HDR_),%b)
&FN`GET`BITLEVEL Scene System=if(u(fn`is`staff,%0),2,1)
&FN`GET`CONFIG Scene System=if(%1,[iter(if(%0,u(w`query,get`config`specific:|:~,%0),u(w`query,get`config`all:|:~,%0)),[first(%i0,~)]~[firstof(u(w`query,get`config`anytable,first(%i0,~),scene_id,%1),first(rest(%i0,~),~))]~[rest(rest(%i0,~),~)],|,|)],[u(w`query,get`config[if(%0,`specific,`all)]:|:~,%0)])
&FN`GET`CONFIG`TABLES Scene System=u(w`query,get`config`tableinscene,%0,%1)
&FN`GET`CREATIONLINE Scene System=if(not(u(fn`is`validcreationline,%0)),#-1 INVALID CREATIONLINE,u(fn`get`creationline`result,%0)
&FN`GET`CREATIONLINE`DO Scene System=null(regeditall(%0,v(fn`is`validcreationline`regexp),[setq(FieldValue,setunion(%q<FieldValue>,$<FIELD>|$<VALUE>$<VALUEQ>,[chr(160)],,[chr(160)]))]))[setq(TableValue,iter(edit(setdiff(u(w`query,get`table,v(data`sql`table`config),%%),scene_id scene_owner scene_ctime scene_etime scene_state scene_players),scene_,),%i0))][setr(FirstValue,squish(iter(%q<FieldValue>,grab(%q<TableValue>,first(%i0,|)*),chr(160))))][setr(OutPutRegister,setdiff(iter(%q<FieldValue>,first(%i0,|),chr(160)),%q<FirstValue>))]
&FN`GET`CREATIONLINE`RESULT Scene System=null(u(fn`get`creationline`do,%0))%q<FieldValue>
&FN`GET`CREATIONLINE`USELESS Scene System=if(u(fn`get`creationline`result,%0)%q<OutPutRegister>,%q<OutPutRegister>,0)
&FN`GET`DATABASE Scene System=default(me/data`sql`database,scene)
&FN`GET`DEFAULT Scene System=
&FN`GET`DEFAULT`SCHEDULETIMELINE Scene System=time()|[convsecs(add(secs(),stringsecs(dec(u(data`scheduledefault))d)))]
&FN`GET`FULLTABLE Scene System=if( match(config players poser poses tags,%0) , [if(u(data`sql`database),[u(data`sql`database)].,scene.)][default(me/data`sql`table`%0,scene_[lcstr(%0)])] , #-1 INVALID TABLE )
&FN`GET`HELP Scene System=Gets help-related files.
&FN`GET`HELP`VALIDOPTIONS Scene System=filter(#lambda/if\(u\(fn`is`staff\,%#\)\,1\,not\(match\(%%0\,*wiz*\)\)\),lattr(me/msg`help`**))
&FN`GET`LASTPOSETIME Scene System=
&FN`GET`LASTPOSETIME`PLAYER Scene System=u(w`query,get`pose`info,pose_time,u(w`query,get`pose`id`last`from`player_id_and_scene,%0,%1))
&FN`GET`LIST Scene System=u(w`query,get`scenes`from`status,%0,firstof(%1,0))
&FN`GET`LIST`ROOMRESTRICT Scene System=u(w`query,get`scenes`from`status_room,%0,firstof(%1,0))
&FN`GET`NAME Scene System=name(%0)
&FN`GET`OBJIDS_NOTINROOM Scene System=filterbool(#lambda/not(match(loc(%1),loc(%%0))),u(fn`get`playerobjid,u(fn`get`playerid`allinscene,%0)))
&FN`GET`PLAYER Scene System=
&FN`GET`PLAYER`STATUS Scene System=
&FN`GET`PLAYER`STATUS`INSCENE Scene System=u(w`query,get`status`from`posers,%1,%0)
&FN`GET`PLAYERID Scene System=u(w`query,get`playerid`from`objid,objid(%0))
&FN`GET`PLAYERID`ALLINPOSES Scene System=u(w`query,get`playerid`from`sceneposes,%0)
&FN`GET`PLAYERID`ALLINSCENE Scene System=u(w`query,get`playerid`from`posers,%0)
&FN`GET`PLAYERID`ANNOUNCETO Scene System=u(w`query,get`playerid`announceto)
&FN`GET`PLAYERNAME Scene System=
&FN`GET`PLAYERNAME`FROM Scene System=
&FN`GET`PLAYERNAME`FROM`PLAYERID Scene System=if(setr(Match,pmatch(extract(setr(PlayerInfo,u(w`query,get`player`info::|,%0)),2,1,|))),u(fn`get`name,%q<Match>),extract(%q<PlayerInfo>,3,1,|))
&FN`GET`PLAYERNAME`POSESINSCENE Scene System=u(w`query,get`player`namesinscene%2,%0,%1)[@@(%0: Scene\, %1: Player_ID)]
&FN`GET`PLAYEROBJID Scene System=u(w`query,get`objid`from`playerid,%0)
&FN`GET`RECALLIDS Scene System=switch(strlen(%1):[strlen(%2)],*:0,ERROR!,0:*,u(w`query,get`pose`id`recallrev,%0,0\,%2),u(w`query,get`pose`id`recall,%0,%1,%2))
&FN`GET`RECALLIDS`PREPARE Scene System=setq(i,0)[switch(strlen(%1):[strlen(%2)],*:0,ERROR!,0:*,u(w`prepare,get`pose`id`recallrev,%0,0\,%2),u(w`prepare,get`pose`id`recall,%0,%1,%2))]
&FN`GET`SCENE Scene System=
&FN`GET`SCENE`LASTVALIDACTIVE Scene System=u(w`query,get`scene`lastvalidactive,%0)
&FN`GET`SCENE`LOCK Scene System=firstof(u(w`query,get`scene`info`specific,scene_lock,%0),type^player|type^object)
&FN`GET`SCENE`PLAYERPARTICIPATED Scene System=u(w`query,get`scenes`from`filter`scene_state,firstof(%1,3[@@(Finished)] 2[@@(Unfinished)] 1[@@(Paused)] 0[@@(Active)]),u(w`query,get`scenes`from`player_id,%0))
&FN`GET`SCENE`RECENTATLOC Scene System=u(w`query,get`scene`recentatlocation,%0,u(fn`sql`timeformat,sub(secs(),v(data`recentscenesecs))),u(fn`sql`timeformat),if(%1,,LIMIT 1))
&FN`GET`SCENE`SCENE_WITH_STATE Scene System=u(w`query,get`scenes`from`filter`scene_state,firstof(%1,3[@@(Finished)] 2[@@(Unfinished)] 1[@@(Paused)] 0[@@(Active)],%0)
&FN`GET`SCENE`STATUS Scene System=switch(u(w`query,get`config`tableinscene,scene_state,%0),3,Finished,2,Unfinished,1,Paused,0,Active,#-1 INVALID SCENE STATE!)
&FN`GET`SCHEDULEADDARG Scene System=switch(words(trimpenn(regediti(%0,get(%=`reg),setr(entry,$1 $2 [if(lt(convtime($1 $2),secs()),inc(last(time())),last(time()))]|$3|$4|)),|,r),|),3,trim(%q<entry>,|,r),#-1 INVALID STRING)
&FN`GET`SCHEDULEADDARG`REG Scene System=(.+)/(.+)\s+((?:[01]?[0-9]|2[0-3]):[0-6][0-9])\s+([a-zA-Z0-9!._ ?':-]+)
&FN`GET`SCHEDULETIMEDAYS Scene System=u(w`query,get`time`diff,u(fn`sql`timeformat,convtime(first(%0,|))),u(fn`sql`timeformat,convtime(rest(%0,|))))
&FN`GET`SCHEDULETIMELINE Scene System=convsecs(convtime(first(%0,-)))[if(rest(%0,-),|[convsecs(convtime(rest(%0,-)))])]
&FN`GET`SMARTSECONDS Scene System=if(isnum(%0),bound(%0,firstof(%1,v(data`minsmartsecs)),firstof(%2,v(data`maxsmartsecs))),reswitch([stringsecs(squish(regeditall(%0,and,,(\\d+)\\s?(hours?|hrs?|min(?\:ute)?s?|sec(?\:ond)?s?|days?),$1[left($2,1)])))],\\d+,#$,#-1)
&FN`GET`STATE Scene System=u(w`query,get`config`tableinscene,scene_state,%0)
&FN`GET`STATE`TONUM Scene System=iter(%0,switch(%i0,finished,3,unfinished,2,paused,1,active,0,all,%%,%i0))
&FN`GET`STATE`TOWORD Scene System=switch(%0,3,finished,2,unfinished,1,paused,0,active,%0)
&FN`GET`TABLE Scene System=if( match(config players poser poses tags,%0) , default(me/data`sql`table`%0,scene_[lcstr(%0)]) , #-1 INVALID TABLE )
&FN`GET`TABLE`LIST Scene System=iter(lattr(me/data`sql`table`),last(%i0,`))
&FN`GET`TABLENAME Scene System=udefault(me/data`sql`table`%0,#-1 INVALID TABLE)
&FN`HAS Scene System=
&FN`HAS`SCHEDULEDSCENE Scene System=u(w`query,get`schedule`ids`ondaybyplayer,u(me/fn`sql`timeformat,convtime(first(%0,|))),u(fn`get`playerid,%1))
&FN`IS Scene System=Holds the SceneSys functions that deals with true/false determinations or rights etc.
&FN`IS`ABLETOJOIN Scene System=and(u(fn`is`scene`id,%0),match(0 1,u(w`query,get`scene`info`specific,scene_state,%0)),u(fn`lock`testlock,u(fn`get`scene`lock,%0),%1))
&FN`IS`ABLETOTELEPORT Scene System=or(and(elock(%0/teleport,%1),or(hasflag(%0,tel_ok),orflags(%1,Wr))),v(data`alwaystel))
&FN`IS`EXITSIMILAR Scene System=match(iter(iter(lexits(%1),u(fn`exitpair,%i0)),u(fn`get`name,%0) [udefault(%i0/odrop,arrives from [u(fn`get`name,loc(%i0))])],,|),%2,|)
&FN`IS`HELPTOPIC Scene System=match(u(fn`get`help`validoptions),msg`help`[edit(%0,%b,_)])
&FN`IS`IC Scene System=switch([isic(%0)],#-1*,pemit(%#,Please tell your staffer to install an ISIC function and point them at %!/fn`is`ic),#$)
&FN`IS`IDLE Scene System=and([gt(sub(secs(),convtime(u(fn`get`lastposetime`player,%0,%1))),v(data`max`idletodeactivate))],[gt(if(#[idle(%2)],idle(%2),[sub(secs(),convtime(get(%2/lastlogout)))]),v(data`max`idletodeactivate))])
&FN`IS`INSCENE Scene System=t(match(u(w`query,get`playerid`from`posers,%1),%0))
&FN`IS`OOCCHATTER Scene System=regmatchi(left(%0,5),(\\b)+?OOC(\\b)+?)
&FN`IS`PLAYERID Scene System=u(w`query,get`playerid`from`playerid,%0)
&FN`IS`POSE_ID Scene System=u(w`query,get`pose`id`poseid,%0)
&FN`IS`RIGHTVERSION Scene System=t(#[comp(extract(version(),3,3),v(data`minimumversion))])
&FN`IS`SCENE Scene System=
&FN`IS`SCENE`ID Scene System=u(w`query,get`scenes`from`sceneid,%0)
&FN`IS`SCENE`ORDERED Scene System=u(w`query,get`config`tableinscene,scene_ordered,%0)
&FN`IS`SCENEOWNER Scene System=match(u(w`query,get`scene`owner,%0),u(fn`get`playerid,%1))
&FN`IS`SETUP Scene System=firstof(regmatch(%u,v(fn`is`setup`regexp)),t(u(fn`get`playerid,%:)),0)
&FN`IS`SETUP`REGEXP Scene System=^[@+-=!.~]?scene(?:/|\s+#)((de|re)?setup|help)(?:\s+(.+))?$
&FN`IS`SPAM Scene System=or(gt(u(w`query,GET`TIME`BETWEEN,POSES,scene_id,%0,poser_id,%2,pose_time,u(fn`sql`timeformat,sub(secs(),10)),u(fn`sql`timeformat,secs())),u(w`query,get`scene`spamtimer,%0)),u(w`query,get`playerid`spammer,%2))
&FN`IS`STAFF Scene System=switch([isstaff(%0)],#-1 FUNCTION *,orflags(%0,Wr),stext(0))
&FN`IS`TABLE Scene System=u(w`query,get`table,%0,%1)
&FN`IS`TOANNOUNCETO Scene System=match(u(w`query,get`player`warnings,%0),%1,\,)
&FN`IS`VALID Scene System=
&FN`IS`VALID`SCHEDULEARG Scene System=lmath(and,switch(u(fn`get`scheduleaddarg,%0),* * *|*|*,#[convtime(squish($0 $1 $3:00 $2))],#-1 INVALID SCHEDULING STRING))
&FN`IS`VALID`SCHEDULEID Scene System=strlen(u(w`query,get`schedule`ids`byids,%0))
&FN`IS`VALID`SCHEDULETIMELINE Scene System=and(lmath(and,u(fn`get`scheduletimeline,%0),|),#[lmath(sub,revwords(iter(u(fn`get`scheduletimeline,%0),convtime(%i0),|)))])
&FN`IS`VALIDCREATIONLINE Scene System=localize(not(strlen(regeditall(%0,v(fn`is`validcreationline`regexp),))))
&FN`IS`VALIDCREATIONLINE`REGEXP Scene System=(?P<FIELD>\w+)=\s*("(?P<VALUEQ>[^"]+)"|(?P<VALUE>[^ ]+?))(\s|$)
&FN`ISLOGGED Scene System=if(and(not(u(fn`is`exitsimilar,%0,loc(%1))),not(u(fn`is`oocchatter,%2)),setr(PlayerID,u(fn`get`playerid,%1)),gte(words(%2),u(data`minposewords)),not(u(fn`is`exitsimilar,%0,loc(%1))),setr(SceneID,u(fn`get`activescene,%q<PlayerID>)),not(u(fn`is`spam,%q<SceneID>,%1,%q<PlayerID>))),\[[ansi(hg,LOG: %q<SceneID>)]\]%b)[if(setr(LocalScene,u(fn`get`scene`recentatloc,objid(loc(%1)),1)),[switch(%q<LocalScene>,u(fn`get`activescene,u(fn`get`playerid,%1)),,%b[ansi(hw,\[[ansi(hr,X)]\])]%b)])]
&FN`ISQUISH Scene System=trim(fold(me/fn`isquish`logic,unique(sort(%0,n))))
&FN`ISQUISH`LOGIC Scene System=if(eq(%1,inc(last(last(%0),-))),strcat(extract(%0,1,dec(words(%0))),%b,first(last(%0),-),-,%1),%0 %1)
&FN`LOCATE Scene System=locate(%#,%0,*y)
&FN`LOCK Scene System=Holds the SceneSys functions that deal with locking users. This uses the testlock() function that was created during development of PennMUSH 1.8.3p11: Which is why this system requires an updated version of PennMUSH.                                                                                                                                                To make compatibility easier - if your ServerBase has something similar to testlock(<lock text>,<victim>), or if you'd rather make a different LOCK syntax - you can alter: &fn`lock`testlock to make use of it.                                                                                              It asumes certain 'replies' from this function to allow a lock to be set. So if you wish to make your own syntax, note that it requires to do the following: In case of 'invalid locktext' --> '#-1 INVALID BOOLEXP', In case of 'victim does not pass' --> 0, In case of 'victim passes' --> 1.
&FN`LOCK`TESTLOCK Scene System=testlock(%0,%1)
&FN`MSG Scene System=u(data`msgprefix) [udefault(msg`[edit(%0,%b,`)],%0,%1,%2,%3,%4,%5,%6,%7,%8,%9)]
&FN`NUMLIST Scene System=sort(setdiff(unique(sort(iter(%0,lnum(max(first(%i0,-),last(%i0,-)),min(first(%i0,-),last(%i0,-)))))),if(%1,numlist(%1))),n)
&FN`SET Scene System=Used to set basic information.
&FN`SET`ACTIVESCENE Scene System=u(w`update,set`activescene,switch(%0,,NULL,NULL,NULL,"%0"),%1)
&FN`SET`CONFIG Scene System=setq(Table,setdiff(%1,scene_id scene_players [@@(scene_state)] scene_owner))[reswitch(strlen(%0)%3,0\[23\],u(w`update,config`defaultset,%q<Table>,%2),1\[1-9\]*,u(w`update,config`sceneset,%q<Table>,%2,firstof(%0,u(fn`get`activescene,%4))),#-1 INVALID BITLEVEL)][@@(We're using w`update to check if it worked or not!)]
&FN`SET`POSE Scene System=u(w`update,pose`add,%0,objid(%1),u(fn`get`name,%1),u(fn`sql`timeformat),objid(loc(%1)),u(fn`get`name,loc(%1)))
&FN`SET`POSE`ORDERMOVE Scene System=iter(0 1 2 3 4 5,u(w`update,pose`moveorderid`%i0,%0,%1,%2,%3)%r[u(w`prepare,pose`moveorderid`%i0,%0,%1,%2,%3)]%r,,%r)
&FN`SET`POSE`PLAIN Scene System=u(w`update,pose`updateplain,%0,%1)
&FN`SET`POSE`PLAINADD Scene System=u(w`update,pose`updateplainadd,%0,%1)
&FN`SET`POSERS Scene System=Sets info for the 'posers' table.
&FN`SET`POSERS`JOIN Scene System=u(w`update,poser`add,%0,%1)[@@(%0: Scene ID\, %1: Player ID)]
&FN`SET`POSERS`REMOVE Scene System=u(w`update,poser`rem,%0,%1)[@@({%0: Scene ID, %1: Player ID})]
&FN`SQL Scene System=Used for special SQL functions, like the 'timeformat'.
&FN`SQL`TIMEFORMAT Scene System=timefmt($Y-$m-$d  $H:$M:$S,firstof(%0,secs()))
&FN`TEL Scene System=if(%0,u(fn`display`cmdtag,[default(me/data`telcommand,@tel)] [first(%0,~)],[default(me/data`telcommand,@tel)] [first(%0,~)]),)
&INCLUDE Scene System=This system uses @include a lot to enhance the effects of this system. All of these includes must be called as an @trig from an OUTSIDE source!
@set Scene System/INCLUDE=no_command
&INCLUDE`ACTIVATE Scene System=@@ Activates a scene for a player.                                                                                                  Arguments= %0: Scene ID, %1: PlayerObjid, %2: PlayerID, %3: Report To                                                                                     ; @assert u(fn`is`inscene,%2,%0)=                                              @pemit %3=u(fn`msg,activate`joinfirst)                                     ; th u(fn`set`activescene,%0,%2)                                             ; @dol u(fn`get`playerobjid,u(fn`get`playerid`allinscene,%0))=                 @pemit %iL=u(fn`msg,activate`done,%il,%2,%1,%0)
&INCLUDE`CONFIGSET Scene System=@@ This gets triggered to set arguments. We'll mainly be making use of fn`set`config in this.                                                                                                               Arguments= SceneID: %0 - ReportTo: %1 - Setting: %2 - Value: %3                                                                                           ; @assert if(strlen(%1),or(u(fn`is`sceneowner,%0,%1),                                                u(fn`is`staff,%1)),1)=                                 @pemit %1=u(fn`msg,notsceneowner)                                                                                                                       ; @assert isnum(setr(ConfigID,u(fn`set`config,%0,%2,%3,                                setr(Bitlevel,u(fn`get`bitlevel,%0,%1)),%0)))=                       @pemit %1=u(fn`msg,configwentwrong,%0,%2,%3,%q<ConfigID>,%q<Bitlevel>)     ; @pemit %1=u(fn`msg,configset,%0,%2,%3,                                                 firstof(%0,u(fn`get`activescene,%1)),%q<Bitlevel>)
&INCLUDE`CONNECT Scene System=
&INCLUDE`CONNECT`MISSED_POSE Scene System=@@ We will check based on the person's LASTLOGOUT, if they missed a pose, and then @pemit him how many in each scene, and the +scene/recall format for it. ; th %N missed the following poses: [setr(PoseIDs, [u(w`query,get`pose`from_till_now,u(fn`sql`timeformat,convtime(get(%#/lastlogout))), setr(SceneID,u(fn`get`activescene,u(fn`get`playerid,%:))) )] )] ; @assert %q<PoseIDs>; @wait 3=@inc %vm={Our records indicate you missed some poses. Use +scene/recall [words(%q<PoseIDs>)]=%q<SceneID>}
&INCLUDE`CREATE Scene System=@@ This is the include that gets run to create a scene. It will use a simple regexp to generate scene information, or report errors if the syntax was not valid. It will then use the creation subattributes, matched with the fields given (excluding the string 'scene_'), to sequencially set up a scene.                                                                                                                              Arguments= %0: CreationLine, %1: PlayerObjid                                                                                                              ; @assert u(fn`is`validcreationline,%0)=                                       @pemit %1=u(fn`msg,creationline_bad,u(fn`filter`creationlineerrors,%0))                                                                                 ; @break setr(UselessLine,u(fn`get`creationline`useless,                              setr(CreationLine,u(fn`get`creationline,%0))))=                       @pemit %1=u(fn`msg,creationline_useless,%q<UselessLine>)                                                                                                ; @@ We create the scene ahead of time. It will set %q<SceneID>.             ; @include me/include`create`make=%1                                                                                                                      ; @@ Now that we have a scene in %q<SceneID>, we run all the 'last keys' of the entered creation string as seperate edits to the scene.                                                                                               ; @dol/d [chr(160)] [u(me/fn`filter`creationlinedoubles,%q<CreationLine>)] =   @include me/include`create`[first(%il,|)] =  rest(%il,|) , %q<SceneID> ,                                                  %1 , u(fn`get`playerid,%1) ; @remit loc(%1)=u(fn`msg,%N has started a new scene (%q<SceneID>) here\, use +scene/join to join the moment they've posed - or use [u(fn`display`cmdtag,+scene/join %q<SceneID>)].)
&INCLUDE`CREATE`ANNOUNCE Scene System=@@ Announces, or doesn't announce, a scene upon creation.                                                                                                                                                 Argument= %0: Value, %1: SceneID, %2: PlayerObjid, %3: PlayerID                                                                                           ; @assert and(%0,not(match(no off,%0)))                                      ; @wait 1=                                                                     {  @include me/include`configset=%1,%2,scene_announce,%0                      ; @dol u(fn`get`playerid`announceto)=                                          @pemit setr(PlayerRef,u(fn`get`playerobjid,##))=                                   u(me/fn`msg,announcecreate,%0,%1,%2,%3,%q<PlayerRef>) }
&INCLUDE`CREATE`DESC Scene System=@@ Sets the description of the scene to a certain value upon creation.                                                                                                                                  Argument= %0: Value, %1: SceneID, %2: PlayerObjid, %3: PlayerID                                                                                           ; @include me/include`configset=%1,%2,scene_desc,%0
&INCLUDE`CREATE`LOCK Scene System=@@ Sets a lock to ward people from the scene.                                                                                    Argument= %0: Value, %1: SceneID, %2: PlayerObjid, %3: PlayerID                                                                                           ; @pemit %2=u(fn`msg,lockset,%0,%2,%1)                                       ; @include me/include`config=                                                           %1,%2,scene_lock,switch(u(fn`lock`testlock,%0,%2),#-1*,#TRUE,%0)
&INCLUDE`CREATE`MAKE Scene System=@@ We create a basic 'scene'. And we then keep the value for its sceneID in %q<SceneID>                                                                                                                      Arguments> %0: PlayerObjid                                                                                                                                ; th u(w`query,set`basicscene,%0,u(fn`get`playerid,%0),u(fn`sql`timeformat))      [setq(SceneID,u(w`query,get`scene`latest))]                                                                                                          ; @@ We tell the creator the succeeded.                                      ; @pemit %0=u(fn`msg,scene`create,%q<SceneID>)                               ; @@ And add them to their own scene.                                        ; @include me/include`scene`addplayer=%q<SceneID>,%0,1,%0
&INCLUDE`CREATE`ORDERED Scene System=@@ Sets a scene to police the pose-order.                                                                                     Argument= %0: Value, %1: SceneID, %2: PlayerObjid, %3: PlayerID                                                                                           ; @include me/include`config=                                                           %1,%2,scene_ordered,reswitch(%0,off|no,0,t(%0))
&INCLUDE`CREATE`PRIVATE Scene System=@@ Sets a scene to private, only allowing the players who were in it - and staff - to read the log.                                                                                                     Argument= %0: Value, %1: SceneID, %2: PlayerObjid, %3: PlayerID                                                                                           ; @include me/include`config=                                                           %1,%2,scene_private,reswitch(%0,off|no,0,t(%0))
&INCLUDE`CREATE`SPAM_TIMER Scene System=@@ Sets a scene's alloted poses per 10 seconds - per player. Should be at least 2 - realistic-wise and to prevent double-poses from getting marked - and max of 7 to make sure nobody abuses this setting..                                                                                                                                            Argument= %0: Value, %1: SceneID, %2: PlayerObjid, %3: PlayerID                                                                                           ; @include me/include`config=                                                           %1,%2,spam_timer,bound(if(isnum(%0),%0,2),2,7)
&INCLUDE`CREATE`TIMEOUT_PAUSE Scene System=@@ Sets a scene's alotted time before its  status is set to 'pause'.                                                                                                                                 Argument= %0: Value, %1: SceneID, %2: PlayerObjid, %3: PlayerID                                                                                           ; @assert setr(Seconds,fn`get`smartseconds,%0)=                                @pemit %#=u(fn`msg,invalidtimestring)                                                                                                                   ; @include me/include`config=%1,%2,timeout_skip,%q<Seconds>
&INCLUDE`CREATE`TIMEOUT_SKIP Scene System=@@ Sets a scene's alotted time before one is 'skipped' on the game. Basically, it means one is 'away' - but 'skip' is more generalized.                                                                                                                                         Argument= %0: Value, %1: SceneID, %2: PlayerObjid, %3: PlayerID                                                                                           ; @assert setr(T,fn`get`smartseconds,%0)=                                      @pemit %#=u(fn`msg,invalidtimestring)                                                                                                                   ; @include me/include`config=                                                           %1,%2,timeout_skip,u(fn`get`smartseconds,%0)
&INCLUDE`CREATE`TIMEOUT_UNFINISHED Scene System=@@ Sets a scene's alotted time before its  status is set to 'unfinished'.                                                                                                                       Argument= %0: Value, %1: SceneID, %2: PlayerObjid, %3: PlayerID                                                                                           ; @assert setr(Seconds,fn`get`smartseconds,%0)=                                @pemit %#=u(fn`msg,invalidtimestring)                                                                                                                   ; @include me/include`config=%1,%2,timeout_skip,%q<Seconds>
&INCLUDE`CREATE`TITLE Scene System=@@ Sets the title of the scene to a certain value upon creation. If you want, you could filter the value here for swears etc.                                                                               Argument= %0: Value, %1: SceneID, %2: PlayerObjid, %3: PlayerID                                                                                           ; @include me/include`configset=%1,%2,scene_title,%0
&INCLUDE`DEACTIVATE Scene System=@@ De-activates the scene you are currently in. A staffer can force this on a player. Does not leave a scene!                                                                                               Arguments= %0: PlayerID, %1: ReportTo, %2: Executor, %3: Optional Comment                                                                                 ; th u(fn`set`activescene,NULL,%0)                                           ; @pemit %1=u(fn`msg,deactivate,%1,%2,%3)                                    ; @break match(%1,%2)                                                        ; @pemit %2=u(fn`msg,deactivate`done,%1,%2,%3)
&INCLUDE`JOIN Scene System=@@ Triggers when someone is added to a scene.
&INCLUDE`KICK Scene System=@@ This is an event include. It runs when someone has already been kicked from a scene.                                                                                                                         Arguments = %0: Kicked Player DBref, %1: SceneID, %2: Executor objid                                                                                      ; @pemit/list filter(fn`is`staff,lwho())=u(fn`msg,kick`event,%2,%0,%1)
&INCLUDE`LASTPOSE Scene System=
&INCLUDE`LASTPOSE`CATCHPOSE Scene System=@assert u(fn`is`ic,%1);@trig me/include`pose=[u(fn`get`name,%1)] , %1 , %0 , [u(fn`sql`timeformat)]
&INCLUDE`LASTPOSE`POSTPOSE Scene System=@assert u(fn`is`ic,%1) ; @dol/inline [lockfilter(lastpose`post:1,lvplayers(%L))]=@pemit ##=%r[u(fn`display`footer,<%b[u(fn`islogged,name(%1),%1,%0)]End of [ansi(hw,accname(%1))]'s pose%b>,,##)] ; &lastpose %#=%qR ; &lastpose`secs %#=[secs()] ; &observe %1=0
&INCLUDE`LASTPOSE`PREPOSE Scene System=@assert u(fn`is`ic,%1) ; @dol/inline [lockfilter(lastpose`pre:1,lvplayers(%L))]=@nspemit ##=u(fn`display`header,<%b[u(fn`islogged,name(%1),%1,%0)][ansi(+white,accname(%1))] has posed%b>,,##)%r
&INCLUDE`LEAVE Scene System=@@ Run when a person leaves a scene of their own volition.                                                                                                                                                 Arguments = %0: Scene ID, %1: Target Objid                                                                                                               ; @include me/include`scene`remplayer=%0,%1,%2                               ; @include me/include`deactivate=u(fn`get`playerid,%1),%1,%1
&INCLUDE`LOOP Scene System=@@ This is the main loop that continues to be run by this system, it will @trig itself at the end to keep this loop going. Make sure this room is powered as NO_PAY, or it will run out of money real fast like.                                                                              ; @@ First, we find all the TASKS to run, and trigger those!                 ; @dolist lattr(me/include`loop`**)=@trig me/%iL                                                                                                          ; @@ And here is the main process loop trigger.                              ; @wait 20=@trig me/include`loop
@set Scene System/INCLUDE`LOOP=no_debug
&INCLUDE`LOOP`PLAYER Scene System=@@ Checks based on player-status.
&INCLUDE`LOOP`PLAYER`TIMEOUT Scene System=@@ Based on a player-timeout.
&INCLUDE`LOOP`PLAYER`TIMEOUT`IDLE Scene System=@@ Check if a player has timed out in any scenes, and should be set idle.                                                                                                                       ; @dol u(w`query,get`playerid`hasactivescene)=                                 {                                                                                th [setq(SceneID,u(fn`get`activescene,%iL))]                               ; th [setq(PlayerObjid,u(fn`get`playerobjid,%iL))]                           ; @switch u(fn`is`idle,%iL,%q<SceneID>,%q<PlayerObjid>) =                      1,                                                                             { @include me/include`deactivate=%iL,%q<PlayerObjid>,%!,Idle }         }
&INCLUDE`LOOP`PLAYER`TIMEOUT`SKIP Scene System=@@ Check if a player has timed out in any scenes, and should be set skip.
&INCLUDE`LOOP`SCENE Scene System=@@ Checks based on system-status.
&INCLUDE`LOOP`SCENE`TIMEOUT Scene System=@@ Based on a player-timeout.
&INCLUDE`LOOP`SCENE`TIMEOUT`PAUSE Scene System=@@ Check for scene-activity. Are there any scenes that should be set as 'paused'? ; @dol u(w`query,get`scene`forpause_auto)=@inc me/include`configset=##,u(fn`get`playerobjid,u(w`query,get`scene`ownerid,##)),scene_state,1
&INCLUDE`LOOP`SCENE`TIMEOUT`UNFINISHED Scene System=@@ Check for scene-activity. Are there any scenes that should be set as 'paused'? ; @dol u(w`query,get`scene`forunfinished_auto)={ @inc me/include`configset=##,setr(PlayerObjid,[if(isobjid(setr(OwnerObjid,u(fn`get`playerobjid, u(w`query,get`scene`ownerid,##))) ),%q<OwnerObjid>,u(fn`get`playerobjid,1))]),scene_state,2 ; @pemit %q<PlayerObjid>=u(fn`msg,setunfinished,##,%q<OwnerObjid>,%q<PlayerObjid>); }
&INCLUDE`OVERRIDE Scene System=@dol @emit pose say semipose=@hook/override ##=me,override`##
&INCLUDE`PLAYER Scene System=Player based triggers. Such as the setup.
&INCLUDE`PLAYER`DESETUP Scene System=@@ This disables a player on the SceneSys playerid list!                                                                                                                                            Arguments= ReportTo: %0 - ObjId: %1                                                                                                                       ; @assert %1=                                                                  @pemit owner(%!)=u(fn`msg,TRIG`PLAYER`DESETUP: %%1 returned nothing.)[@@(%1 is nothing? Then we do nothing!)]                                                                                                         ; @assert u(fn`is`playerid,%1)=                                                @pemit %0=u(fn`msg,playerid`not)[@@(Should be self explainatory.)]         ; th u(w`query,player`desetup,%1)[@@(And we remove them!)]                   ; @pemit %0=u(fn`msg,setup`removed,%1)
&INCLUDE`PLAYER`RESETUP Scene System=@@ This disables a player on the SceneSys playerid list!                                                                                                                                            Arguments= ReportTo: %0 - ObjId: %1                                                                                                                       ; @assert %1=                                                                  @pemit owner(%!)=u(fn`msg,TRIG`PLAYER`RESETUP: %%1 returned nothing.)[@@(%1 is nothing? Then we do nothing!)]                                                                                                         ; @assert u(fn`is`playerid,%1)=                                                @pemit %0=u(fn`msg,playerid`not)[@@(Should be self explainatory.)]                                                                                      ; th u(w`query,player`resetup,%1)[@@(And we remove them!)]                   ; @pemit %0=u(fn`msg,setup`resetup,%1)
&INCLUDE`PLAYER`SETUP Scene System=@@ This sets up a player for using the SceneSys!                                                                           Arguments= ReportTo: %0 - ObjId: %1                                                                                                                       ; @assert %1=                                                                  @pemit owner(%!)=u(fn`msg,TRIG`PLAYER`SETUP: %%1 returned nothing.)[@@(%0 is nothing? Then we do nothing!)]                                                                                                                        ; @break u(fn`get`playerid,%1)=                                                @pemit %0=u(fn`msg,setup`alreadydone,%1)[@@(They are already setup. Silly people!)]                                                                                                                                                 ; th u(w`query,player`setup,%1,u(fn`get`name,%1),u(fn`get`bitlevel,%1))[@@(And we set them up!)]                                                               ; @pemit %0=u(fn`msg,setup`complete,%1)
&INCLUDE`POSE Scene System=@@ This is what gets triggered when a room detects something being said. Here we filter things and run around main system. This is important!                                                                                                                                             Arguments= %0: Playername - %1: ObjectID - %2: ANSI Pose.                                                                                                 ; @assert match(v(data`listento),type(%1))[@@(We only listen to certain types of object types!)]                                                                                                                                  ; @break u(fn`is`oocchatter,%2)[@@(We won't listen to OOC chatter!)]                                                                                     ; @assert setr(PlayerID,u(fn`get`playerid,%1))                                        [@@(We don't listen to anyone who is not set up for this system!)]                                                                               ; @assert gte(words(%2),v(data`minposewords))[@@(We asume a pose should have a minimum length. This is to drown out movement messages and people spamming the SceneSys.)]                                                                                                                                          ; @break u(fn`is`exitsimilar,%0,loc(%1))[@@(Ugly check for whether or not something was exit talk.)]                                                                                                                                ; @assert setr(SceneID,u(fn`get`activescene,%q<PlayerID>))                     [@@(If we cannot find an active scene for them\, we'll let include`pose`noactivescene figure out what to do next)]=                       @include me/include`pose`noactivescene = %0,%1,%2,%4                                                                                                    ; @break u(fn`is`spam,%q<SceneID>,%1,%q<PlayerID>)=                            @include me/include`spam=%q<SceneID>,%1                                                                                                                 ; @include me/include`pose`announce = %1,%q<SceneID>,%l,%2                   ; @include me/include`pose`[if(u(fn`get`scene`ordered,%q<SceneID>)                                      ,order,add)] = %1,%q<SceneID>,%1,%2
&INCLUDE`POSE`ADD Scene System=@@ This will add a pose to the database. It will require the 'active scene' to have been figured out ahead of time.                                                                                        Arguments= %0: ReportTo, %1: SceneID, %2: Poser, %3: Pose                                                                                                ; @assert lt(strlen(edit(%3,%t,space(4))),mul(setr(BufferMax,sub(u(data`maxbuffer),10)),2))=     @pemit %0=u(fn`msg,The pose was too big to record. Please chop it down to [mul(%q<BufferMax>,2)] characters.)                                                                                                                      ; @@ We split up this code, so we can hold the most information in the attribute, and get around the annoying COMMAND_LEN buffer problem.                                                                                        ; th setq(PoseReport,u(fn`set`pose,%1,%2))                                   ; th u(fn`set`pose`plain,mid(edit(%3,%t,space(4)),0,%q<BufferMax>),%q<PoseReport>)            ; th u(fn`set`pose`plainadd,                                                      mid(edit(%3,%t,space(4)),%q<BufferMax>,mul(%q<BufferMax>,2)),%q<PoseReport>) ; @break match(2 1,u(fn`get`state,%1))=@inc me/include`configset=%1,[if(isdbref(setr(PlayerObjid,u(fn`get`playerobjid, u(w`query,get`scene`ownerid,%1))) ),%q<PlayerObjid>,u(fn`get`playerobjid,1))],scene_state,0
&INCLUDE`POSE`ANNOUNCE Scene System=@@ This is what gets triggered when a pose gets added. We check for the player 'warnings' they want to listen to.                                                                                        Arguments= Poser: %0 - ActiveSceneID: %1 - Location: %2 - ANSI Pose: %3                                                                                   ; @pemit/list [u(fn`get`objids_notinroom,%1,%0)]=u(fn`msg,[name(%0)] posed to this scene (%1) in another room.)
&INCLUDE`POSE`CHANGE_ORDER Scene System=@@ This will exchange the order_id of two poses within the scene scene.                                                                                                                          Arguments= %0: ReportTo, %1: SceneID, %2: order_id-1, %3: order_id-2                                                                                      ; @assert and(setr(PoseID1,u(w`query,get`pose`id`scene_and_order,%1,%2)),              isint(%1),isint(%2))=                                                @pemit %0=u(fn`msg,nosuchorderid,%2)                                      ; @assert and(setr(PoseID2,u(w`query,get`pose`id`scene_and_order,%1,%3)),              isint(%1),isint(%3))=                                                @pemit %0=u(fn`msg,nosuchorderid,%3)                                      ; th setq(ToNullSuccess,u(w`update,pose`changeorderid,NULL,%q<PoseID1>))     ; th setq(FirstChangeSuccess,u(w`update,pose`changeorderid,%2,%q<PoseID2>))  ; th setq(SecondChangeSuccess,u(w`update,pose`changeorderid,%3,%q<PoseID1>))                                                                              ; @pemit %0=u(fn`msg,orderidexchange,%1,%2,%3)
&INCLUDE`POSE`IGNORE Scene System=@@ This will (un)set a pose_id as 'ignore', and will thus (no longer) ignore it from showing up in logs and scene recalls. This will not DELETE the pose! This is the prefered method or removing poses, to prevent sabotage.                                                                                                                               Arguments= %0: ReportTo, %1: pose_id, %2: on/off                                                                                                          ; @assert u(fn`is`pose_id,%1) =                                                @pemit %0=u(fn`msg,nosuchpose)                                                                                                                          ; @assert setr(Error,u(w`update,set`pose`ignore,t(%2),%1)) =                   @pemit %0=u(fn`msg,somethingwentwrong,%q<Error>,INCLUDE`POSE`IGNORE)       ; @pemit %0=u(fn`msg,ignoreset,%2,%1)
&INCLUDE`POSE`MOVE_ORDER Scene System=@@ This will move the order_id of one pose behind another.                                                                                                                                  Arguments= %0: ReportTo, %1: SceneID, %2: order_id-1, %3: order_id-2                                                                                      ; @assert and(u(w`query,get`pose`id`scene_and_order,%1,%2),                            isint(%1),isint(%2))=                                                @pemit %0=u(fn`msg,nosuchorderid,%2)                                       ; @assert and(u(w`query,get`pose`id`scene_and_order,%1,%3,replace),                    isint(%1),isint(%3))=                                                @pemit %0=u(fn`msg,nosuchorderid,%3)                                      ; th setq(MaxID,inc(u(w`query,get`pose`order_id`max,%1)))                    ; th u(me/fn`set`pose`ordermove,%2,%3,%q<MaxID>,%1)
&INCLUDE`POSE`NOACTIVESCENE Scene System=@@ This is what gets triggered if there was no active scene detected for the player.                                                                                                                 Arguments = %1:
&INCLUDE`RECALL Scene System=@@ This is the scene recall include. It recalls poses from the scene as defined.                                                                                                                                Arguments= %0: Recall Min, %1: Recall Max, %2: Scene ID                                                                                                   ;  @mapsql me/include`recall`line=setq(PlayerDBref,%#)[setr(Prepare,u(fn`get`recallids`prepare,%2,%0,%1))][setq(RecallIDs,words(sql(%q<Prepare>)))]
&INCLUDE`RECALL`LINE Scene System=@nspemit %q<PlayerDBref>=u(fn`display`recallpose,r(POSE_ID,args),%0,%q<RecallIDs>)
&INCLUDE`SCENE Scene System=Holds the removal and addition of players.
&INCLUDE`SCENE`ADDPLAYER Scene System=@@ This runs to add a player to a scene. It assumes things like locks have been checked ahead of time, so that it can add people like staff to a scene as well, as well as letting scene-owners and staffers 'add' a player to a scene, circumventing 'private' locks or locks in general. This can still not add a player to a FINISHED or UNFINISHED scene! If it finds a duplicate, it will warn!                                                                                           Arguments= %0: Scene ID, %1: Player Objid, %2: AutoJoin?, %3: Report To                                                                                   ; @assert u(fn`is`scene`id,%0)=                                                @pemit %3=u(fn`msg,nosuchscene,%0)                                                                                                                      ; @assert match(0 1,u(w`query,get`scene`info`specific,scene_state,%0))=        @pemit %3=u(fn`msg,cannotjoinscene`state,%0)                                                                                                            ; @switch u(fn`set`posers`join,%0,u(fn`get`playerid,%1))=                      #-1 * DUPLICATE *                                                            , @pe/li unique(objid(%3) %1)=u(fn`msg,alreadyinscene,%1,objid(%3),%0)       , @pe/li unique(objid(%3) %1)=u(fn`msg,scene`join,%1,objid(%3),%0)                                                                                     ; @assert %2[@@(Autojoin them to the scene?)]                                ; @include me/include`activate=%0,%1,u(fn`get`playerid,%1),%3
&INCLUDE`SCENE`REMPLAYER Scene System=@@ This runs to remove a player from a scene. It assumes things like locks have been checked ahead of time, so that it can remove people like staff from a scene as well, as well as letting scene-owners and staffers 'remove' a player from a scene, circumventing 'private' locks or locks in general. This cannot remove a player from a scene they are not in!                                                                                                                                  Arguments= %0: Scene ID, %1: Player Objid, %2: Report To                                                                                                 ; @assert u(fn`is`scene`id,%0)=                                                @pemit %2=u(fn`msg,nosuchscene,%0)                                                                                                                      ; @assert u(fn`is`inscene,u(fn`get`playerid,%2),%0)=                           @pemit %2=u(fn`msg,notinscene,%0)                                                                                                                      ; @assert match(0 1,u(w`query,get`scene`info`specific,scene_state,%0))=        @pemit %2=u(fn`msg,cannotleavescene`state,%0,%1,%2)                                                                                                     ; th u(fn`set`posers`remove,%0,u(fn`get`playerid,%1))                       ; @dol unique(objid(%2) %1)=                                                   @pemit %il=u(fn`msg,scene`leave,%1,objid(%2),%0,%il)
&INCLUDE`SCHEDULE Scene System=
&INCLUDE`SCHEDULE`ADD Scene System=@@ This include adds a scene to the schedule. It assumes that all the testing has been done by the command. We're expecting the ScheduleData to be in the form of 'MMM DD YYYY|HH:MM|TITLE'.                                                                                          Arguments= %0: SendTo, %1: Player ID, %2: ScheduleData, %3: Scene Description, %4: Character Name, %5: room                                                                                                                 ; @assert setr(ScheduleSet,u(w`update,set`schedule                             ,u(me/fn`sql`timeformat,convtime(switch(%2,* * *|*|*,$0 $1 $3:00 $2,#$)))      ,rest(rest(%2,|),|),%1,%4,%3,%5)) =                                                                                                                       @pemit %0=u(fn`msg,SQL`ERROR,%q<ScheduleSet>)                                                                                                           ; @pemit %0=u(fn`msg,Schedule`Success,%q<ScheduleSet>,%1,%2)                       ; @cemit/noisy Public=[name(%0)] has scheduled a scene[if(%5,%bin the room '[name(%5)]')] on [first(%2,|)] at [elements(%2,2,|)] [timefmt($Z)], titled: '[u(fn`display`cmdtag,+scenes %q<ScheduleSet>,last(%2,|))]'. ; @include me/include`schedule`success=%0,%1,%q<ScheduleSet>,first(%2,|),elements(%2,2,|),last(%2,|),%3,%5
&INCLUDE`SCHEDULE`DEL Scene System=@@ This include deletes a scene from the schedule listing.                                                                                                                                                  Arguments= %0: Respond To, %1: Schedule ID                                                                                                                ; @assert setr(QueryResult,u(w`update,set`schedule`delete,%1))=                @pemit %0=u(fn`msg,SQL`ERROR,%q<QueryResult>)                              ; @pemit %0=u(fn`msg,schedule`del,%1) ; @inc me/include`schedule`del_success=%1
&INCLUDE`SCHEDULE`DEL_SUCCESS Scene System=@break [setr(Find,u(fn`get`bbpost,%0))]=+bbremove [v(data`scheduleboard)]/%q<Find>
&INCLUDE`SCHEDULE`RESCHEDULE Scene System=@@ This include reschedules a scene from the schedule listing.                                                                                                                                     Arguments= %0: Respond To, %1: Schedule ID, %2: New Date                                                                                                  ; @assert setr(ScheduleSet,u(w`update,set`schedule`update,                     u(fn`sql`timeformat,convtime(switch(%2,* * *|*|*,$0 $1 $3:00 $2,#$))),%1)) =    @pemit %0=u(fn`msg,SQL`ERROR,%q<ScheduleSet>)                              ; @pemit %0=u(fn`msg,schedule`reschedule,%0,%1,%2)
&INCLUDE`SCHEDULE`SUCCESS Scene System=+bbpost [v(data`scheduleboard)]/Schedule #%q<ScheduleSet>: %5=[ansi(hw,Title)]: %5%r[ansi(hw,Posted by)]: [name(%0)]%r[ansi(hw,Scheduled Time)]: %3 @ %4[if(%7,%r[ansi(hw,Room)]: [name(%7)] ([u(fn`tel,%7)]))]%r[repeat(-,78)]%r%6
&INCLUDE`SCHEDULE`VIEW Scene System=@@ This include gets called to display a schedule - we are using @retry instead of a map() or iter() in case of long values.                                                                                Arguments= %0: Respond To, %1: Timeline, %2: Timeline Days                                                                                               ; @pemit %0=u(fn`display`header,< Current Schedule in [timefmt($Z)] >)                   ; @dol/notify repeat(1%b,inc(%2))=@pemit %0=[u(fn`display`schedule`day,dec(#@),first(%1,|))]  ; @wait me=@pemit %0=u(fn`display`footer,< [ansi(hw,+scenes #)] >)
&INCLUDE`SPAM Scene System=@@ When spam has been detected, warn the person, and remove them from the scene.                                                                                                                               Arguments= %0: SceneID, %1: PlayerObjid, %2: PlayerID                                                                                                     ; @pemit %1=u(fn`msg,warn`spam,%1,%0)                                        ; @include me/include`scene`remplayer=%0,%1,%!
&MSG Scene System=Holds all messages. There create output which should be handled by a command of function. They do not send anything themselves.
@set Scene System/MSG=no_command
&MSG`ACTIVATE Scene System=
&MSG`ACTIVATE`DONE Scene System=switch(%0,%2,Your active scene is now #%3,u(fn`get`name,%2) activated this scene (%3)).
&MSG`ACTIVATE`JOINFIRST Scene System=You must first join that scene!
&MSG`ALREADYINSCENE Scene System=switch(%0,%1,You are already in scene #%2,u(fn`get`name,%1) tried adding [u(fn`get`name,%0)] to scene #%2\, but they were already in that scene).
&MSG`ANNOUNCECREATE Scene System=[u(fn`get`name,%2)] created scene (#%1) in [u(fn`get`name,loc(%2))][if(u(fn`is`abletoteleport,loc(%2),%4),%b[ansi(hg,\([u(fn`tel,loc(%2))]\))].)]%r[u(fn`msg,{[speak(&[u(fn`get`name,%#)],%0,notes\,)]})]
&MSG`BADVERSION Scene System=Warning! You are running a version of PennMUSH that does NOT support SceneSys. Please make sure to upgrade to PennMUSH [v(data`minimumversion)] or above! If you believe you got this message in error, alter the data`minimumversion attribute to your current version.
&MSG`CANNOTADDTOSCENE Scene System=You cannot add %1 to scene #1 because you do not have the permissions to do so.
&MSG`CANNOTJOINSCENE Scene System=switch(s:%0,s:,There are no recent scenes in this room.,s:%1,You cannot join scene %0.,A general error occured. You cannot join this scene.)
&MSG`CANNOTJOINSCENE`STATE Scene System=You cannot join scene %0 because of its scene-state.
&MSG`CANNOTLEAVESCENE Scene System=
&MSG`CANNOTLEAVESCENE`STATE Scene System=You cannot leave that scene, as it is set as 'Finished' or 'Unfinished'. Use +scene/deactivate instead.
&MSG`CANNOTREMFROMSCENE Scene System=You do not have the permission to remove that player from the scene.
&MSG`CANTFIND Scene System=No matter how hard I tried\, I could not find '%0'!
&MSG`CONFIGSET Scene System=reswitch(strlen(%0)%4,0\[23\],Defaults for '%1' set to '%2'.,1\[123\]*,Scene '%0' option '%1' set to '[u(w`query,get`config`anytable,%1,scene_id,%0)]'.,#-1 INVALID BITLEVEL)
&MSG`CONFIGWENTWRONG Scene System=switch(%3,#-1 SQL ERROR: Unknown column*,You tried to alter an invalid option.,#-1 SQL ERROR: Invalid default value for*,You specified invalid value '%2' for '%1'.,#-1 SQL ERROR: Data truncated for column*,You specified invalid value '%2' for '%1'.,Something went wrong! @mail your admin with the following: %3)
&MSG`CREATIONLINE_BAD Scene System=Bad syntax for the scene creation: %0
&MSG`CREATIONLINE_USELESS Scene System=There were leftover creation variables we didn't know what to do with: [itemize(iter(%0,ansi(hw,%i0)))].
&MSG`DEACTIVATE Scene System=switch(%1,%0,You've deactivated your current scene.,switch(%1,%!,SceneSys,name(%1)) has deactivated you from your current scene. [if(strlen(%2),Reason: %2)])
&MSG`DEACTIVATE`DONE Scene System=You have deactivated [name(%0)]'s current scene.
&MSG`DONTOWNSCHEDULE Scene System=You don't own that schedule entry.
&MSG`HELP Scene System=Contains helpfiles, for the users. These get read using the fn`display`help function.
&MSG`HELP`ACTIVATE Scene System=Syntax: %r%t[v(data`gameprefix)]scene/activate%r%t[v(data`gameprefix)]scene/deactivate%r%rWorkings:%r%rActivates or deactivates you from a scene. Making your poses (no longer) be directed to a certain scene!
&MSG`HELP`ADDPLAYER Scene System=[ansi(hw,Syntax:)]%r[space(4)]+scene/addplayer <Scene>=<Player>%r%rAs a scene-owner, allows you to add a person to your scene. Do not abuse this!
&MSG`HELP`COMMON Scene System=Common commands and command aliasses: %r%t* +scene/title <id>=<title>%r%t* +scene/desc <id>=<description>%r%t* +scene/create title="<title>"%r%t* +scene/create announce="Running a scene!"%r%t* +scene/create title="<title>" announce="<announcement>"%r%t* +scene/finish
&MSG`HELP`CONFIG Scene System=Syntax: %r%t[v(data`gameprefix)]scene/config [ansi(hm,<)][ansi(hw,Scene)][ansi(hm,>)]%r%t[v(data`gameprefix)]scene/config [ansi(hm,<)][ansi(hw,Scene)][ansi(hm,>)]/[ansi(hm,<)][ansi(hw,Setting)][ansi(hm,>)]%r%t[v(data`gameprefix)]scene/config [ansi(hm,<)][ansi(hw,Setting)][ansi(hm,>)]=[ansi(hm,<)][ansi(hw,Value)][ansi(hm,>)]%r%t[v(data`gameprefix)]scene/config [ansi(hm,<)][ansi(hw,Scene)][ansi(hm,>)]/[ansi(hm,<)][ansi(hw,Setting)][ansi(hm,>)]=[ansi(hm,<)][ansi(hw,Value)][ansi(hm,>)]%r%rDisplay, or change the setting on one of your scenes, such as the title, or the description. It may be useful to check +scene/config so you know exactly what 'settings' there are to edit.
&MSG`HELP`CREATE Scene System=Syntax: %r%t[v(data`gameprefix)]scene/create option=value option2="another value" (etc)%r%rThis system will create a scene, with you as the scene owner. Valid options are listed below:%r%r[align(20(hc) [sub(width(%#),21)](hc),Option:,Explanation:)]%r[iter(setdiff(u(w`query,get`table,v(data`sql`table`config),%%),scene_id scene_owner scene_ctime scene_etime scene_state scene_players),align(20(h) [sub(width(%#),21)],edit(%i0,scene_,):,u(w`query,get`tablecomment,v(data`sql`table`config),%i0)),,%r)]
&MSG`HELP`CREDIT Scene System=Credit to the SceneSys, and all rights, go to: %r%rMercutio@M*U*S*H / Oathkeeper@FinalKingdomMUSH%rEmail: admin@twilightdays.org.%r%rInfo on SceneSys: %r%thttp://www.tumblr.com/blog/mush-mercutio %r%thttp://www.tumblr.com/tagged/scenesys
&MSG`HELP`FINISH Scene System=Syntax: %r%t[v(data`gameprefix)]scene/finish%r%rWorkings:%r%rWill set the scene as 'finished'. No more poses will be recorded in this scene. If you wish to un-finish it, or set it back to active, change the value using +scene/config (until a better option is implemented).
&MSG`HELP`HELP Scene System=Syntax: %r%t[v(data`gameprefix)]scene/help%r%t[v(data`gameprefix)]scene/help [ansi(hm,<)][ansi(hw,topic)][ansi(hm,>)]%r%rWorkings:%r%rIt's what you are using right now!
&MSG`HELP`INFO Scene System=Syntax: %r%t[v(data`gameprefix)]scene/info ([ansi(hm,<[ansi(hw,Scene ID)]>)])%r%rWorkings:%r%rThis lets you see the basic information about a scene. Without an argument, you simply get to see the one you are active in.
&MSG`HELP`LEAVE Scene System=Syntax: %r%t[v(data`gameprefix)]scene/leave%r%t[v(data`gameprefix)]scene [ansi(hm,<)][ansi(hw,SceneID)][ansi(hm,>)]%r%rLeaves a scene. [ansi(hr,This is not the same as deactivating)] a scene. Deactivating a scene simply stops your poses from being recorded in that scene. Leaving it means you get no more information from that log. (You are considered 'not being in that scene). %r%rThis is the command you want if you accidentally join a scene.
&MSG`HELP`LIST Scene System=Syntax: %r%t[v(data`gameprefix)]scene/list%r%t[v(data`gameprefix)]scene/list [ansi(hm,<)][ansi(hw,Statuses)][ansi(hm,>)]%r%rWorkings:%r%rDisplays all the scenes that match a certain status, or multiple statuses. Valid statuses are: 'finished', 'unfinished','active' and 'paused'. %r%r'[v(data`defaultlist)]' is the default.
&MSG`HELP`MINE Scene System=Syntax: %r%t[v(data`gameprefix)]scene/mine%r%t[v(data`gameprefix)]scene/mine/finished%r%t[v(data`gameprefix)]scene/mine/unfinished%r%rWorkings:%r%rShows your 'mine' screen. Numbering your completed scenes, and giving some basic info on scenes you are currently part of; paused or unfinished. The second command displays the scenes you /finished/ rather than the ones that are active. And /unfinished does the next logical thing.
&MSG`HELP`MOVE Scene System=Syntax:%r%t[v(data`gameprefix)]scene/move [ansi(hm,<)][ansi(hw,Order ID)][ansi(hm,>)]=[ansi(hm,<)][ansi(hw,Order ID)][ansi(hm,>)]%r%t[v(data`gameprefix)]scene/move [ansi(hm,<)][ansi(hw,SceneId)][ansi(hm,>)]/[ansi(hm,<)][ansi(hw,Order ID)][ansi(hm,>)]=[ansi(hm,<)][ansi(hw,Order ID)][ansi(hm,>)]%r%t[v(data`gameprefix)]scene/move [ansi(hm,<)][ansi(hw,Order ID)][ansi(hm,>)]=[ansi(hm,<)][ansi(hw,Up/Down/+/-)][ansi(hm,>)] [ansi(hm,<)][ansi(hw,Count)][ansi(hm,>)]%r%t[v(data`gameprefix)]scene/move [ansi(hm,<)][ansi(hw,SceneId)][ansi(hm,>)]/[ansi(hm,<)][ansi(hw,Order ID)][ansi(hm,>)]=[ansi(hm,<)][ansi(hw,Up/Down/+/-)][ansi(hm,>)] [ansi(hm,<)][ansi(hw,Count)][ansi(hm,>)]%r%t[v(data`gameprefix)]scene/move [ansi(hm,<)][ansi(hw,Order ID)][ansi(hm,>)]=[ansi(hm,<)][ansi(hw,Above/Under)][ansi(hm,>)] [ansi(hm,<)][ansi(hw,Order ID)][ansi(hm,>)]%r%t[v(data`gameprefix)]scene/move [ansi(hm,<)][ansi(hw,SceneId)][ansi(hm,>)]/[ansi(hm,<)][ansi(hw,Order ID)][ansi(hm,>)]=[ansi(hm,<)][ansi(hw,Above/Under)][ansi(hm,>)] [ansi(hm,<)][ansi(hw,Order ID)][ansi(hm,>)]%r%rWorkings:%r%rThese are a lot of commands to do the same thing. Move poses around in a scene.%r%rThe first two commands are to exchange two poses' position.%r%rThe second two commands move a pose up or down by a certain number.%r%rThe last two commands move a pose into a position above or under another - as one would find it in the [v(data`gameprefix)]scene/recall listing.
&MSG`HELP`POSE Scene System=A 'pose' is defined as anything done, while [ansi(hwu,active)] in a scene, the scene itself being [ansi(hwu,active)] as well, and having more than [v(data`minposewords)] 'words' in it.
&MSG`HELP`RECALL Scene System=Syntax:%r%t[v(data`gameprefix)]scene/recall %r%t[v(data`gameprefix)]scene/recall [ansi(hm,<)][ansi(hw,Quantity)][ansi(hm,>)]%r%t[v(data`gameprefix)]scene/recall [ansi(hm,<)][ansi(hw,Quantity)][ansi(hm,>)]=[ansi(hm,<)][ansi(hw,Scene)][ansi(hm,>)]%r%rWorkings:%r%rThe first command shows the last couple of poses in your scene. %r%rThe second version lets you indicate how many poses to display since the last. You can alternatively indicate a number-range like '5-10', to read pose 5-10.%r%rThe third version works much like the first, but also allows for indication of what scene's recall you wish to read.
&MSG`HELP`SCENE Scene System=Syntax: %r%t[v(data`gameprefix)]scene%r%t[v(data`gameprefix)]scene [ansi(hm,<)][ansi(hw,SceneID)][ansi(hm,>)]%r%rWorkings:%r%rThe first option shows the same screen as +scene/mine. The second shows the scene's +scene/info.
&MSG`HELP`SCHEDULE Scene System=Syntax: %r%t+scene/schedule [ansi(hm,<)][ansi(hw,Date Range)][ansi(hm,>)]%r%t+scene/schedule/view [ansi(hm,<)][ansi(hw,Schedule ID)][ansi(hm,>)]%r%t+scene/schedule/add [ansi(hm,<)][ansi(hw,Month)][ansi(hm,>)]/[ansi(hm,<)][ansi(hw,Day)][ansi(hm,>)] [ansi(hm,<)][ansi(hw,Time)][ansi(hm,>)] [ansi(hm,<)][ansi(hw,Title)][ansi(hm,>)]=[ansi(hm,<)][ansi(hw,Description)][ansi(hm,>)]%r%t+scene/schedule/add/here [ansi(hm,<)][ansi(hw,Month)][ansi(hm,>)]/[ansi(hm,<)][ansi(hw,Day)][ansi(hm,>)] [ansi(hm,<)][ansi(hw,Time)][ansi(hm,>)] [ansi(hm,<)][ansi(hw,Title)][ansi(hm,>)]=[ansi(hm,<)][ansi(hw,Description)][ansi(hm,>)]%r%t+scene/schedule/reschedule [ansi(hm,<)][ansi(hw,Schedule ID)][ansi(hm,>)]=[ansi(hm,<)][ansi(hw,Month)][ansi(hm,>)] [ansi(hm,<)][ansi(hw,Day)][ansi(hm,>)] [ansi(hm,<)][ansi(hw,Time)][ansi(hm,>)]%r%t+scene/schedule/del [ansi(hm,<)][ansi(hw,Schedule ID)][ansi(hm,>)]%r%rWorkings:%r%rThe first command lists the schedule of scenes planned for the coming [spellnum(u(data`scheduledefault))] days. If you wish to indicate a daterange, you can do so. It accepts a 'month day year-month day year' where year is optional.%r%rThe second command allows you to view a schedule'd scene - that is to say, read the title, date and most importantly, its /description/.%r%rThe third command allows you to schedule a scene. [ansi(hr,The time is required to be in 24h format)], and presumes [ansi(u,this server's timezone)] ([timefmt($Z)]). It is [extract(elements(time(),4),1,2,:)] now.%r%rThe alternative fourth also indicates what room the scene will be in. [ansi(hur,It uses the room you are /currently/ in as the room!)], that means [name(%l)] in your case right now! %r%rThe fifth command is similar to the third one. It simply reschedules a scene you already have planned. Please try not to reschedule scenes that have already taken place - but it won't disallow it!%r%rThe last command allows you to delete a scheduled scene from the system. Just point it at the ID.%r%r[ansi(hg,Examples)]: %r[space(4)]+scene/schedule/reschedule 999=February 20 19:30%r[space(4)]+scene/schedule/add 06/20 18:32 This is a Scene=This is my description%r[space(4)]+scene/schedule/add/here 06/20 18:32 This is a Scene=This is my description
&MSG`HELP`SETUP Scene System=Syntax: %r%t[v(data`gameprefix)]scene/setup %r%t[v(data`gameprefix)]scene/desetup %r%t[v(data`gameprefix)]scene/resetup%r%rWorkings:%r%rSets you up for the use of the Scene System. Desetup and resetup do the logical thing - but do not assign you a new playerid.
&MSG`HELP`STATE Scene System=There are a total of three states in the system at this time. %r%r0 ([ansi(hgu,Active)]) - A scene is being RPed in currently. People can join freely. They show up in [u(fn`display`cmdtag,+scene/mine)] and [u(fn`display`cmdtag,+scene/list)].%r[u(fn`display`midline)]%r1 ([ansi(hyu,Paused)]) - The same as Active in all ways but visual representation. Pose in the scene to reset it to active.%r[u(fn`display`midline)]%r2 ([ansi(u,Unfinished)]) - New characters can no longer 'join' this scene - but a member of the scene can '+scene/activate' it. Pose in the scene to set it active again. You can find your unfinished scenes in [u(fn`display`cmdtag,+scene/mine/unfinished)].%r[u(fn`display`midline)]%r3 ([ansi(hwu,Finished)]) - A scene is set this way because of someone using +scene/finish or setting it in the config options. People can no longer join it, poses are no longer recorded. If you wish to amend or continue in the scene, first use: [ansi(h,+scene/config [ansi(m,<)]SceneID[ansi(m,>)]/scene_state=0)]. [u(fn`display`cmdtag,+scene/mine/finished)] to see your finished scenes.
&MSG`HELP`SYNTAX Scene System=The scene system, even though it indicates all commands in the following format: [ansi(hw,[v(data`gameprefix)]scene/[ansi(hm,<[ansi(hw,subsystem)]>)] [ansi(hm,<[ansi(hw,arguments)]>)])]... but it also accepts different manners of writing it.%r%r[ansi(hw,Prefix:)] + - @  = ! . ~ or simply no prefix are all accepted.%r[space(4)][ansi(hw,Example:)] '@scene' or '.scene' or simply 'scene'%r%r[ansi(hw,Subsystem:)] #subsystem or /subsystem%r[space(4)][ansi(hw,Example:)] 'scene/info 1' or 'scene #info 1'
&MSG`HELP`UNDO Scene System=Syntax: %r%t[v(data`gameprefix)]scene/undo%r%rWhen you just posed, and made a mistake in the pose, you can use +scene/undo to toss this pose - telling the system to ignore it for display purposes. Not that you can only undo your last pose - though if it's really needed, you can use +scene/move in order to forcibly override this.
&MSG`HELP`WIZCONFIG Scene System=Syntax: %r%t[v(data`gameprefix)]scene/config ([ansi(hm,<)][ansi(hw,Scene Or Setting)][ansi(hm,>)])%r%t[v(data`gameprefix)]scene/config/set ([ansi(hm,<)][ansi(hw,Scene)][ansi(hm,>)]/)[ansi(hm,<)][ansi(hw,Setting)][ansi(hm,>)]=[ansi(hm,<)][ansi(hw,Value)][ansi(hm,>)]%r%rWorkings:%r%rThe first command is for displaying purposes only. The second sets a setting in a scene. If no scene is defined - it sets the global defaults!
&MSG`HELP`WIZINSTALL Scene System=TO BE REWRITTEN. %r%rSee the data`install attribute for manual install requirements and hints.
&MSG`HELP`WIZMINE Scene System=Syntax: %r%t[v(data`gameprefix)]scene/mine [ansi(hm,<)][ansi(hw,Player)][ansi(hm,>)]%r%rWorkings:%r%rShows that player's 'mine' screen.
&MSG`HELP`WIZSETUP Scene System=Syntax: %r%t[v(data`gameprefix)]scene/setup [ansi(hm,<)][ansi(hw,Player)][ansi(hm,>)]%r%t[v(data`gameprefix)]scene/desetup [ansi(hm,<)][ansi(hw,Player)][ansi(hm,>)]%r%t[v(data`gameprefix)]scene/resetup [ansi(hm,<)][ansi(hw,Player)][ansi(hm,>)]%r%rWorkings:%r%rSets you up for the use of the Scene System. Desetup and resetup do the logical thing - but do not assign you a new playerid.
&MSG`IGNORESET Scene System=Ignore to pose %1 has been turned [if(%0,on,off)].
&MSG`INSTALL Scene System=
&MSG`INSTALL`DONE Scene System=Install done! We hope...
&MSG`INSTALL`NOPARENT Scene System=Please give a valid room DB. Because we can't find your room parent. Another option is to set your ancestor_room in @config // mush.cnf.
&MSG`INSTALL`SQLCHECK Scene System=
&MSG`INSTALL`SQLCHECK`BAD Scene System=Something went wrong. There are tables we do not recognize, or there are tables missing. We cannot quite tell. The following were left over from a 'diff' between your database and the tables in DATA`SQL`TABLES: %0. If you need any assistance, please contact Mercutio. See: [ansi(hw,ex %!/credits)]
&MSG`INVALIDSCHEDULETIMELINE Scene System=Sorry, [ansi(hw,%0)] is not a valid timeline.
&MSG`INVALIDSTATUS Scene System=ansi(hr,%0) is an invalid scene status. Try 'paused', 'active', 'finished' or 'unfinished'.
&MSG`INVALIDTIMESTRING Scene System=%0 is an invalid timestring.
&MSG`KICK Scene System=
&MSG`KICK`EVENT Scene System=name(%0) kicked name(%1) from scene %2.
&MSG`LOCKSET Scene System=switch(u(fn`lock`testlock,%0,%1),#-1*,Invalid lock. Scene unlocked. Set a proper lock with +scene/config/set %2/scene_lock=<value>.,0,Lock Set: %0\, but you cannot pass it yourself. Seems somewhat silly\, no?,Lock Set: %0.)
&MSG`MOVE Scene System=
&MSG`MOVE`NOTSURE Scene System=We are not sure what to do with this? See '+scene/help move' for help on using this command.
&MSG`NEWPOSE Scene System=name(%2) just posed to your current scene.
&MSG`NOACTIVESCENE Scene System=You have no scene set as 'active'.
&MSG`NOHELPFILE Scene System=No such file found: %0
&MSG`NOPOSEBYPLAYER Scene System=No pose made by [switch(%0,%1,you,name(%0))] yet.
&MSG`NOSCHEDULEID Scene System=I could not find a scheduled scene corresponding to that schedule ID.
&MSG`NOSCHEMA Scene System=We do not have SELECT rights to `information_schema`! That's not good! Fix this! Without it, SceneSys won't work properly.
&MSG`NOSUCHORDERID Scene System=if(%2,Replacement is out of bounds (Position %0). Try moving the pose elsewhere.,There is no such OrderId (%0) in that scene!)
&MSG`NOSUCHPLAYER Scene System=No such player found.
&MSG`NOSUCHPLAYERID Scene System=No such playerid found. They may not be set up for the SceneSystem.
&MSG`NOSUCHPOSE Scene System=There is no such pose.
&MSG`NOSUCHSCENE Scene System=if(%0,'%0' is not a valid or existing scene ID.,You are not in a scene\, or there is no active one here. Try giving a scene ID.)
&MSG`NOTSCENEOWNER Scene System=You are not the owner to this scene.
&MSG`NOTSTAFF Scene System=You are not staff.
&MSG`NOUNDONE Scene System=No recent undone poses found to redo.
&MSG`ORDERIDEXCHANGE Scene System=The poses belonging to order_ids %1 and %2 have been exchanged within scene %0.
&MSG`PLAYERID Scene System=
&MSG`PLAYERID`NOT Scene System='%0' is not a valid playerid!
&MSG`SCENE Scene System=
&MSG`SCENE`CREATE Scene System=You successfully created a scene, it is registered under Scene #%0.
&MSG`SCENE`CREATE`TITLE Scene System=Its title is now set as: "[ansi(hw,%0)]".
&MSG`SCENE`JOIN Scene System=switch(%0,%1,You joined scene #%2,u(fn`get`name,%1) added [u(fn`get`name,%0)] to scene #%2).
&MSG`SCENE`LEAVE Scene System=switch(%1:%3,%0:%0,You left scene #%2.,%0:*,u(fn`get`name,%1) left scene #%2,*:%0,You were removed from scene #%2 by [u(fn`get`name,%1)].,u(fn`get`name,%0) was removed from scene #%2 by [u(fn`get`name,%1)].
&MSG`SCHEDULE Scene System=
&MSG`SCHEDULE`ALREADYHAVESCENETHATDAY Scene System=You already have a scene scheduled that day.
&MSG`SCHEDULE`DEL Scene System=Schedule ID %0 has been removed from the system.
&MSG`SCHEDULE`RESCHEDULE Scene System=[name(%0)] rescheduled '%1' to [ansi(hw,%2)].
&MSG`SCHEDULE`SUCCESS Scene System=We've successfully set your scene. You can find it on the schedule on [u(fn`display`cmdtag,+scene/schedule [first(%2,|)],first(%2,|))] as scene [u(fn`display`cmdtag,+scene/schedule/view %0,%0)].
&MSG`SETUNFINISHED Scene System=Scene %0 has been set Unfinished[switch(%1,%2,. You can find it in [u(fn`display`cmdtag,+scene/mine/unfinished)].,%bin a former player's scene.)] See [u(fn`display`cmdtag,+scene/help state)] for help about unfinished scenes.
&MSG`SETUP Scene System=Setup messages. Probably just the 'setup needed' one.
&MSG`SETUP`ALREADYDONE Scene System=You triggered setup for '[u(fn`get`name,%0)] (%0)' while they are already setup! Did you mean to re-setup them?
&MSG`SETUP`COMPLETE Scene System=Setup of [u(fn`get`name,%0)] ([first(%0,:)]) complete.
&MSG`SETUP`NEEDED Scene System=[switch(%0,%#,You,%0)] still need[switch(%0,%#,,s)] to setup for SceneSys. Please use the following command: '[ansi(hw,+scene/setup)]'
&MSG`SETUP`REMOVED Scene System=Player id '%0' has been deactivated from SceneSys.
&MSG`SETUP`RESETUP Scene System=Player id '%0' has been re-setup for SceneSys.
&MSG`SOMETHINGWENTWRONG Scene System=Something went wrong. Please alert your local Wizard - help them with the following message; %r%1:%r%0
&MSG`SQL Scene System=
&MSG`SQL`ERROR Scene System=We found an SQL error, and we don't know what to do with it. Warn your staffer: %0.
&MSG`UNDOLIMIT Scene System=Your most recent pose was already an undone one. Either make a new pose, or ask your sceneowner to remove the following pose; %0
&MSG`WARN Scene System=Time-warning, or spam-warning messages.
&MSG`WARN`SPAM Scene System=Warning. You have been detected to be spamming in scene %1. Thusly, you have been removed from the scene - and the system is locked against you. Please contact a staffer if you believe this to be an unjust action.
&OVERRIDE Scene System=SEE THE DATA`COMMAND_OVERRIDE attribute for information on this attribute tree! MAKE SURE to set it !no_command, or the hooked overrides won't work! And be sure to get yourself a function to use for FN`IS`IC - we default to ISIC()
&OVERRIDE`@EMIT Scene System=$@emit*:@assert or(not(%0),regmatch(%0,(?s)^\\s(.+), s p))=@nspemit %#=Huh?  (Type "help" for help.); th [setr(r,speak(&%N,|%qp))] ; @include/nobreak me/include`lastpose`prepose=%qr,%: ; @message/spoof/remit %l=%qr,emitformat,%0,%#,%n,[accname(%#)],%qp,%qR,,u(fn`islogged,%N,%:,%qr) ; @include me/include`lastpose`postpose=%qr,%: ; @include me/include`lastpose`catchpose=trimpenn(trimpenn(%qr,%t,r),%r),%:
&OVERRIDE`POSE Scene System=$pose*:@assert or(not(%0),regmatch(%0,(?s)^\\s(.+), s p))=@nspemit %#=Huh?  (Type "help" for help.); th [setr(r,speak(&%N,:%qp))] ; @include/nobreak me/include`lastpose`prepose=%qr,%: ; @message/spoof/remit %l=%qr,poseformat,%0,%#,%n,[accname(%#)],%qp,%qr,,u(fn`islogged,%N,%:,%qr) ; @include me/include`lastpose`postpose=%qr,%: ; @include me/include`lastpose`catchpose=trimpenn(%qr,%r),%:
&OVERRIDE`SAY Scene System=$say*:@assert or(not(%0),regmatch(%0,(?s)^\\s(.+), s p))=@nspemit %#=Huh?  (Type "help" for help.); th [setr(r,speak(&%N,%qp))] ; @include/nobreak me/include`lastpose`prepose=%qr,%: ; @message/spoof/remit %l=%qr,sayformat,%0,%#,%n,[accname(%#)],%qp,%qr,[udefault(%#/saymodifier,says,%qp)],u(fn`islogged,%N,%:,%qr) ; @include/nobreak me/include`lastpose`postpose=%qr,%: ; @include me/include`lastpose`catchpose=trimpenn(%qr,%r),%:
&OVERRIDE`SEMIPOSE Scene System=$semipose*:@assert or(not(%0),regmatch(%0,(?s)^\\s(.+), s p))=@nspemit %#=Huh?  (Type "help" for help.); th [setr(r,speak(&%N,;%qp))] ; @include/nobreak me/include`lastpose`prepose=%qr,%: ; @message/spoof/remit %l=%qr,semiposeformat,%0,%#,%n,[accname(%#)],%qp,%qr,,,u(fn`islogged,%N,%:,%qr) ; @include/nobreak me/include`lastpose`postpose=%qr,%: ; @include me/include`lastpose`catchpose=trimpenn(%qr,%r),%:
&SQL Scene System=SQL queries. Using an edited version of Walker's SQL Wrapper to optimize and make more readable.
@set Scene System/SQL=no_command
&SQL`CONFIG Scene System=
&SQL`CONFIG`DEFAULTSET Scene System=ALTER TABLE `$DATABASE$`.`$CONFIG$` ALTER t? SET DEFAULT ?
&SQL`CONFIG`SCENESET Scene System=UPDATE `$DATABASE$`.`$CONFIG$` SET t?=? WHERE `scene_id`=?
&SQL`GET Scene System=
&SQL`GET`ACTIVESCENE Scene System=SELECT `activescene_id` FROM `$DATABASE$`.`$PLAYERS$` WHERE `player_id`=?
&SQL`GET`CONFIG Scene System=
&SQL`GET`CONFIG`ALL Scene System=SELECT `column_name`,`column_default`,`column_comment` FROM `information_schema`.`columns` WHERE `table_name` = 'scene_config'
&SQL`GET`CONFIG`ANYTABLE Scene System=SELECT t? FROM `$DATABASE$`.`$CONFIG$` WHERE t? IN @?
&SQL`GET`CONFIG`SPECIFIC Scene System=SELECT `column_name`,`column_default`,`column_comment` FROM `information_schema`.`columns` WHERE `table_name` = 'scene_config' AND `column_name` = ?
&SQL`GET`CONFIG`TABLEINSCENE Scene System=SELECT t? FROM `$DATABASE$`.`$CONFIG$` WHERE `scene_id`=?
&SQL`GET`INSTALLINFOSCHEMA Scene System=SELECT COUNT(*) FROM `information_schema`.`columns` WHERE `TABLE_SCHEMA`=?
&SQL`GET`INSTALLSHOW Scene System=SHOW TABLES FROM `$DATABASE$`
&SQL`GET`OBJID Scene System=
&SQL`GET`OBJID`FROM Scene System=
&SQL`GET`OBJID`FROM`PLAYERID Scene System=SELECT DISTINCT `player_objid` FROM `$DATABASE$`.`$PLAYERS$` WHERE `player_id` IN @?
&SQL`GET`PLAYER Scene System=
&SQL`GET`PLAYER`INFO Scene System=SELECT * FROM `$DATABASE$`.`$PLAYERS$` WHERE `player_id`=?
&SQL`GET`PLAYER`NAME Scene System=SELECT `player_initname` FROM `$DATABASE$`.`$PLAYERS$` WHERE `player_id`=?
&SQL`GET`PLAYER`NAMESINSCENE Scene System=SELECT DISTINCT `poser_name` FROM `$DATABASE$`.`$POSES$` WHERE `scene_id`=? AND `poser_id`=?
&SQL`GET`PLAYER`STATUS Scene System=
&SQL`GET`PLAYER`WARNINGS Scene System=SELECT `warnings` FROM `$DATABASE$`.`$PLAYERS$` WHERE `player_id`=?
&SQL`GET`PLAYERID Scene System=
&SQL`GET`PLAYERID`ANNOUNCETO Scene System=SELECT `player_id` FROM `$DATABASE$`.`$PLAYERS$` WHERE `scenecreate_announce`="1"
&SQL`GET`PLAYERID`FROM Scene System=
&SQL`GET`PLAYERID`FROM`OBJID Scene System=SELECT `player_id` FROM `$DATABASE$`.`$PLAYERS$` WHERE `player_objid`=?
&SQL`GET`PLAYERID`FROM`PLAYERID Scene System=SELECT `player_id` FROM `$DATABASE$`.`$PLAYERS$` WHERE `player_id` = ?
&SQL`GET`PLAYERID`FROM`POSERS Scene System=SELECT `poser_playerid` FROM `$DATABASE$`.`$POSER$` WHERE `scene_id` = ?
&SQL`GET`PLAYERID`FROM`SCENEPOSES Scene System=SELECT DISTINCT `poser_id` FROM `$DATABASE$`.`$POSES$` WHERE `scene_id`=?
&SQL`GET`PLAYERID`HASACTIVESCENE Scene System=SELECT `player_id` FROM `$DATABASE$`.`$PLAYERS$` WHERE `activescene_id` IS NOT NULL
&SQL`GET`PLAYERID`SPAMMER Scene System=SELECT `spammer` FROM `$DATABASE$`.`$PLAYERS$` WHERE `player_id`=?
&SQL`GET`POSE Scene System=
&SQL`GET`POSE`BODY Scene System=SELECT `pose_penn` FROM `$DATABASE$`.`$POSES$` WHERE `pose_id`=? LIMIT 1
&SQL`GET`POSE`COUNT Scene System=
&SQL`GET`POSE`COUNT`INSCENE Scene System=SELECT COUNT(`pose_id`) FROM `$DATABASE$`.`$POSES$` WHERE `scene_id`=? AND `ignore`="0"
&SQL`GET`POSE`COUNT`INSCENE`FROMPLAYER Scene System=SELECT COUNT(`pose_id`) FROM `$DATABASE$`.`$POSES$` WHERE `poser_id`=? AND `scene_id`=? AND `ignore`="0"
&SQL`GET`POSE`FROM_TILL_NOW Scene System=SELECT `pose_id` FROM `$DATABASE$`.`$POSES$` WHERE ( `pose_time` BETWEEN ? and NOW() ) AND `ignore`=0 AND `scene_id` IN @?
&SQL`GET`POSE`ID Scene System=
&SQL`GET`POSE`ID`LAST Scene System=SELECT `pose_id` FROM `$DATABASE$`.`$POSES$` ORDER BY `pose_id` DESC LIMIT 1
&SQL`GET`POSE`ID`LAST`FROM Scene System=
&SQL`GET`POSE`ID`LAST`FROM`PLAYER_ID Scene System=SELECT `pose_id` FROM `$DATABASE$`.`$POSES$` WHERE `poser_id`=? ORDER BY `pose_id` DESC LIMIT 1
&SQL`GET`POSE`ID`LAST`FROM`PLAYER_ID_AND_SCENE Scene System=SELECT `pose_id` FROM `$DATABASE$`.`$POSES$` WHERE `poser_id`=? AND `scene_id`=? ORDER BY `pose_id` DESC LIMIT 1
&SQL`GET`POSE`ID`POSEID Scene System=SELECT `pose_id` FROM `$DATABASE$`.`$POSES$` WHERE `pose_id`=?
&SQL`GET`POSE`ID`RECALL Scene System=SELECT a.`pose_id` FROM (SELECT `pose_id`,`order_id` FROM `$DATABASE$`.`$POSES$` WHERE `scene_id`=? AND `order_id` BETWEEN ? AND ? AND `ignore`="0") AS a ORDER BY order_id ASC
&SQL`GET`POSE`ID`RECALLREV Scene System=SELECT a.`pose_id` FROM (SELECT `pose_id`,`order_id` FROM `$DATABASE$`.`$POSES$` WHERE `scene_id`=? AND `ignore`="0" ORDER BY order_id DESC LIMIT a?) AS a ORDER BY order_id ASC
&SQL`GET`POSE`ID`SCENE_AND_ORDER Scene System=SELECT `pose_id` FROM `$DATABASE$`.`$POSES$` WHERE `scene_id`=? AND `order_id`=?
&SQL`GET`POSE`IGNORE Scene System=SELECT `ignore` FROM `$DATABASE$`.`$POSES$` WHERE `pose_id`=? LIMIT 1
&SQL`GET`POSE`IGNORE_PLAYERSCENE Scene System=SELECT `ignore` FROM `$DATABASE$`.`$POSES$` WHERE `scene_id`=? AND `poser_id`=? ORDER BY `order_id` DESC LIMIT 1
&SQL`GET`POSE`INFO Scene System=SELECT t? FROM `$DATABASE$`.`$POSES$` WHERE `pose_id`=?
&SQL`GET`POSE`LATEST Scene System=
&SQL`GET`POSE`LATEST`SCENEPLAYER Scene System=SELECT `pose_id` FROM `$DATABASE$`.`$POSES$` WHERE `scene_id`=? AND `poser_id`=? ORDER BY `order_id` DESC LIMIT 1
&SQL`GET`POSE`ORDER Scene System=
&SQL`GET`POSE`ORDER`LASTINSCENE Scene System=SELECT `order_id` FROM `$DATABASE$`.`$POSES$` WHERE `scene_id`=? ORDER BY `order_id` DESC LIMIT 1
&SQL`GET`POSE`ORDER_ID Scene System=
&SQL`GET`POSE`ORDER_ID`MAX Scene System=SELECT MAX(`order_id`) FROM `$DATABASE$`.`$POSES$` WHERE `scene_id`=?
&SQL`GET`POSE`POSER Scene System=SELECT `poser_name` FROM `$DATABASE$`.`$POSES$` WHERE `pose_id`=? LIMIT 1
&SQL`GET`POSE`TABLEINFO Scene System=SELECT t? FROM `$DATABASE$`.`$POSES$` WHERE `pose_id`=? LIMIT 1
&SQL`GET`SCENE Scene System=
&SQL`GET`SCENE`FORPAUSE Scene System=SELECT * FROM ( SELECT poses.`scene_id`,`scene_ctime`,`pose_time` FROM `$DATABASE$`.`$POSES$` as poses INNER JOIN `$DATABASE$`.`$CONFIG$` as config ON poses.`scene_id`=config.`scene_id` AND `scene_state`='0' GROUP BY config.scene_id ORDER BY pose_time DESC ) as groupedcontent WHERE NOT (`pose_time` BETWEEN ?<0> AND ?<1> OR `scene_ctime` BETWEEN ?<0> AND ?<1>)
&SQL`GET`SCENE`FORPAUSE_AUTO Scene System=SELECT scene_id FROM ( SELECT DISTINCT config.`scene_id`,`scene_ctime`,MAX(`pose_time`) as pose_time,`timeout_skip`,`timeout_pause`,`timeout_unfinished` FROM `$DATABASE$`.`$POSES$` as poses INNER JOIN `$DATABASE$`.`$CONFIG$` as config ON poses.`scene_id`=config.`scene_id` AND `scene_state`='0' GROUP BY config.scene_id ORDER BY pose_time DESC ) as groupedcontent WHERE NOT ( (`pose_time` BETWEEN (NOW()- INTERVAL `timeout_pause` SECOND) AND NOW()) OR (`scene_ctime` BETWEEN (NOW()- INTERVAL `timeout_pause` SECOND) AND NOW() ) )
&SQL`GET`SCENE`FORPAUSE_AUTO2 Scene System=SELECT scene_id FROM ( SELECT DISTINCT config.`scene_id`,`scene_ctime`,MAX(`pose_time`) as pose_time,`timeout_skip`,`timeout_pause`,`timeout_unfinished` FROM `$DATABASE$`.`$POSES$` as poses INNER JOIN `$DATABASE$`.`$CONFIG$` as config ON poses.`scene_id`=config.`scene_id` AND `scene_state`='0' GROUP BY config.scene_id ORDER BY pose_time DESC ) as groupedcontent WHERE NOT ( (`pose_time` BETWEEN (NOW()- INTERVAL `timeout_pause` SECOND) AND NOW()) OR (`scene_ctime` BETWEEN (NOW()- INTERVAL `timeout_pause` SECOND) AND NOW() ) )
&SQL`GET`SCENE`FORUNFINISHED_AUTO Scene System=SELECT scene_id FROM ( SELECT DISTINCT config.`scene_id`,`scene_ctime`,MAX(`pose_time`) as pose_time,`timeout_skip`,`timeout_pause`,`timeout_unfinished` FROM `$DATABASE$`.`$POSES$` as poses INNER JOIN `$DATABASE$`.`$CONFIG$` as config ON poses.`scene_id`=config.`scene_id` AND `scene_state` IN ('0','1') GROUP BY config.scene_id ORDER BY pose_time DESC ) as groupedcontent WHERE NOT ( (`pose_time` BETWEEN (NOW()- INTERVAL `timeout_unfinished` SECOND) AND NOW()) OR (`scene_ctime` BETWEEN (NOW()- INTERVAL `timeout_unfinished` SECOND) AND NOW() ) )
&SQL`GET`SCENE`INFO Scene System=SELECT * FROM `$DATABASE$`.`$CONFIG$` WHERE `scene_id`=?
&SQL`GET`SCENE`INFO`SPECIFIC Scene System=SELECT t? FROM `$DATABASE$`.`$CONFIG$` WHERE `scene_id`=?
&SQL`GET`SCENE`LASTVALIDACTIVE Scene System=SELECT `$CONFIG$`.`scene_id` FROM `$DATABASE$`.`$POSES$` INNER JOIN `$DATABASE$`.`$CONFIG$` ON `$POSES$`.`scene_id`=`$CONFIG$`.`scene_id` WHERE `poser_id`=? AND (`scene_state`="1" OR `scene_state`="0") ORDER BY `pose_time` DESC LIMIT 1
&SQL`GET`SCENE`LATEST Scene System=SELECT `scene_id` FROM `$DATABASE$`.`$CONFIG$` ORDER BY `scene_id` DESC LIMIT 1
&SQL`GET`SCENE`LISTINFO Scene System=SELECT `scene_title`,`scene_owner`,`scene_ctime`,`scene_etime`,`scene_ordered`,`scene_state` FROM `$DATABASE$`.`$CONFIG$` WHERE `scene_id`=? AND `scene_private`="0"
&SQL`GET`SCENE`OWNER Scene System=SELECT `scene_owner` FROM `$DATABASE$`.`$CONFIG$` WHERE `scene_id`=?
&SQL`GET`SCENE`OWNERID Scene System=SELECT `scene_owner` FROM `$DATABASE$`.`$CONFIG$` WHERE `scene_id`=?
&SQL`GET`SCENE`RECENTATLOCATION Scene System=SELECT `$CONFIG$`.`scene_id` FROM `$DATABASE$`.`$POSES$` INNER JOIN `$DATABASE$`.`$CONFIG$` ON `$POSES$`.`scene_id`=`$CONFIG$`.`scene_id` WHERE `pose_room`=? AND (`scene_state`="1" OR `scene_state`="0") AND (`pose_time` BETWEEN ? AND ? OR `scene_ctime` BETWEEN ?<1> AND ?<2>) ORDER BY `pose_time` DESC LIMIT 1
&SQL`GET`SCENE`RECENTATLOCATION`ALL Scene System=SELECT DISTINCT `$CONFIG$`.`scene_id` FROM `$DATABASE$`.`$POSES$` INNER JOIN `$DATABASE$`.`$CONFIG$` ON `$POSES$`.`scene_id`=`$CONFIG$`.`scene_id` WHERE `pose_room`=? AND (`scene_state`="1" OR `scene_state`="0") AND `pose_time` BETWEEN ? AND ? ORDER BY `pose_time` DESC a?
&SQL`GET`SCENE`SPAMTIMER Scene System=SELECT `spam_timer` FROM `$DATABASE$`.`$CONFIG$` WHERE `scene_id`=?
&SQL`GET`SCENES Scene System=Gets scene IDs
&SQL`GET`SCENES`FROM Scene System=
&SQL`GET`SCENES`FROM`FILTER Scene System=
&SQL`GET`SCENES`FROM`FILTER`SCENE_STATE Scene System=SELECT `scene_id` FROM `$DATABASE$`.`$CONFIG$` WHERE `scene_state` IN @? and `scene_id` IN @?
&SQL`GET`SCENES`FROM`PLAYER_ID Scene System=SELECT `scene_id` FROM `$DATABASE$`.`$POSER$` WHERE `poser_playerid` IN @?
&SQL`GET`SCENES`FROM`SCENEID Scene System=SELECT `scene_id` FROM `$DATABASE$`.`$CONFIG$` WHERE `scene_id` IN @?
&SQL`GET`SCENES`FROM`STATUS Scene System=SELECT `scene_id` FROM `$DATABASE$`.`$CONFIG$` WHERE `scene_state` IN @? AND `scene_private` IN @?
&SQL`GET`SCENES`FROM`STATUS_ROOM Scene System=SELECT `scene_id` FROM `$DATABASE$`.`$CONFIG$` WHERE `scene_state` LIKE ? AND `pose_room`=? AND `scene_private` IN @?
&SQL`GET`SCHEDULE Scene System=
&SQL`GET`SCHEDULE`FULLBYID Scene System=SELECT * FROM `$DATABASE$`.`$SCHEDULE$` WHERE `id`=?
&SQL`GET`SCHEDULE`IDS Scene System=SELECT `id` FROM `$DATABASE$`.`$SCHEDULE$` WHERE `time` BETWEEN ? AND ? ORDER BY `time` ASC
&SQL`GET`SCHEDULE`IDS`BYIDS Scene System=SELECT `id` FROM `$DATABASE$`.`$SCHEDULE$` WHERE `id` IN @?
&SQL`GET`SCHEDULE`IDS`ONDAYBYPLAYER Scene System=SELECT `id` FROM `$DATABASE$`.`$SCHEDULE$` WHERE CAST(`time` AS DATE) = CAST(? AS DATE) AND `player_id`= ?
&SQL`GET`STATUS Scene System=
&SQL`GET`STATUS`FROM Scene System=
&SQL`GET`STATUS`FROM`POSERS Scene System=SELECT `poser_skip` FROM `$DATABASE$`.`$POSER$` WHERE `scene_id`=? AND `poser_playerid`=?
&SQL`GET`TABLE Scene System=SELECT `column_name` FROM `information_schema`.`columns` WHERE `table_name` = ? AND `column_name` LIKE ?
&SQL`GET`TABLECOMMENT Scene System=SELECT `column_comment` FROM `information_schema`.`columns` WHERE `table_name` = ? AND `column_name` LIKE ?
&SQL`GET`TIME Scene System=
&SQL`GET`TIME`BETWEEN Scene System=SELECT COUNT(*) FROM d? WHERE t?=? AND t?=? AND (t? BETWEEN ? AND ?)
&SQL`GET`TIME`DIFF Scene System=SELECT IFNULL(ABS(DATEDIFF(?,?)),0)
&SQL`PLAYER Scene System=
&SQL`PLAYER`DESETUP Scene System=UPDATE `$DATABASE$`.`$PLAYERS$` SET `setup`="0" WHERE `player_id`=?
&SQL`PLAYER`RESETUP Scene System=UPDATE `$DATABASE$`.`$PLAYERS$` SET `setup`="1" WHERE `player_id`=?
&SQL`PLAYER`SETUP Scene System=INSERT INTO `$DATABASE$`.`$PLAYERS$` (player_objid,player_initname,bitlevel) VALUES (?,?,?)
&SQL`POSE Scene System=
&SQL`POSE`ADD Scene System=INSERT INTO `$DATABASE$`.`$POSES$` (order_id,scene_id,owner_id,poser_id,poser_name,pose_time,pose_room,pose_room_name) VALUES ( IFNULL( (SELECT `order_id` FROM `$DATABASE$`.`$POSES$` as x WHERE x.`scene_id`=?<0> ORDER BY x.`order_id` DESC LIMIT 1) ,0)+1 , ?<0> , (SELECT `scene_owner` FROM `$DATABASE$`.`$CONFIG$` WHERE `scene_id`=?<0>) , (SELECT `player_id` FROM `$DATABASE$`.`$PLAYERS$` WHERE `player_objid`=?<1>) ,?<2>,?<3>,?<4>,?<5> )
&SQL`POSE`CHANGEORDERID Scene System=UPDATE `$DATABASE$`.`$POSES$` SET `order_id`=a? WHERE `pose_id`=?
&SQL`POSE`MOVEORDERID Scene System=
&SQL`POSE`MOVEORDERID`0 Scene System=START TRANSACTION
&SQL`POSE`MOVEORDERID`1 Scene System=UPDATE `$DATABASE$`.`$POSES$` SET `order_id`=`order_id`+?<2> WHERE `order_id`>=LEAST(CONVERT(?<0>,SIGNED),CONVERT(?<1>,SIGNED)) AND `scene_id`=?<3>
&SQL`POSE`MOVEORDERID`2 Scene System=UPDATE `$DATABASE$`.`$POSES$` SET `order_id`=?<1> WHERE `order_id`=?<0>+?<2> AND `scene_id`=?<3>
&SQL`POSE`MOVEORDERID`3 Scene System=UPDATE `$DATABASE$`.`$POSES$` SET `order_id`=`order_id`-?<2>+SIGN(?<0>-?<1>) WHERE `scene_id`=?<3> AND `order_id`!=?<1> AND `order_id` BETWEEN ?<1> AND GREATEST(CONVERT(?<0>,SIGNED),CONVERT(?<1>,SIGNED))+?<2>
&SQL`POSE`MOVEORDERID`4 Scene System=UPDATE `$DATABASE$`.`$POSES$` SET `order_id`=`order_id`-?<2> WHERE `scene_id`=?<3> AND `order_id`>GREATEST(CONVERT(?<0>,SIGNED),CONVERT(?<1>,SIGNED))+?<2>
&SQL`POSE`MOVEORDERID`5 Scene System=COMMIT
&SQL`POSE`UPDATEPLAIN Scene System=UPDATE `$DATABASE$`.`$POSES$` SET `pose_penn`=? WHERE `pose_id`=?
&SQL`POSE`UPDATEPLAINADD Scene System=UPDATE `$DATABASE$`.`$POSES$` SET `pose_penn`=CONCAT( (SELECT `pose_penn` FROM (SELECT `pose_id`,`pose_penn` FROM `$DATABASE$`.`$POSES$`) AS x WHERE x.pose_id=?<1>) ,?<0>) WHERE pose_id=?<1>
&SQL`POSER Scene System=
&SQL`POSER`ADD Scene System=INSERT INTO `$DATABASE$`.`$POSER$` (`scene_id`,`poser_playerid`) VALUES (?,?)
&SQL`POSER`REM Scene System=DELETE FROM `$DATABASE$`.`$POSER$` WHERE `scene_id`=? AND `poser_playerid`=?
&SQL`SET Scene System=
&SQL`SET`ACTIVESCENE Scene System=UPDATE `$DATABASE$`.`$PLAYERS$` SET `activescene_id`=a? WHERE `player_id`=?
&SQL`SET`BASICSCENE Scene System=INSERT INTO `$DATABASE$`.`$CONFIG$` (`scene_players`,`scene_owner`,`scene_ctime`,`scene_state`) VALUES (?,?,?,"0")
&SQL`SET`POSE Scene System=
&SQL`SET`POSE`IGNORE Scene System=UPDATE `$DATABASE$`.`$POSES$` SET `ignore`=? WHERE `pose_id`=?
&SQL`SET`SCHEDULE Scene System=INSERT INTO `$DATABASE$`.`$SCHEDULE$` (time,title,player_id,name,description,room) VALUES (?,?,?,?,?,?)
&SQL`SET`SCHEDULE`DELETE Scene System=DELETE FROM `$DATABASE$`.`$SCHEDULE$` WHERE `id`=?
&SQL`SET`SCHEDULE`UPDATE Scene System=UPDATE `$DATABASE$`.`$SCHEDULE$` SET `time`=? WHERE `id`=?
&STARTUP Scene System=@@ This will initialize the main trigger loop - that does most of the 'smart' work of this system. Make sure this object is set NO_PAY - see the TRIG`LOOP attribute comment. And while we are at it, may as well make sure we have the minimum required @config values.                                                                                                    ; @config/set player_queue_limit=[inc(u(data`maxbuffer))]                    ; @include/nobreak me/include`loop ;  @assert u(data`command_override); @include me/include`override
@set Scene System/STARTUP=no_command prefixmatch
&W Scene System=Contains Walker's SQL Wrapper, slightly editted. Quoting walker; "Yes, it's ugly code, but it's ugly so yours can be clean!"
@set Scene System/W=no_debug
&W`ARGUMENTS Scene System=Contains the w`arguments used in front of the '?' sign. Example: t? will assume a 'table', d? will automatically insert the 'database', and add on your 'table' argument. Stuff like that. To add new ones, simply add a 'system', which will get '%0' as the text as the incoming argument, and 'sign' underneath that to indicate what 'symbol' before the ? to associate with. Example: &w`arguments`capitalized_a wrapper="[sqlescape(edit(%0,a,A))]" (( and then )) &w`arguments`captalized_a`sign wrapper=&   (( Mind you not to use '=' as a 'sign'! ))
@set Scene System/W`ARGUMENTS=no_debug
&W`ARGUMENTS`ARRAY Scene System=([map(#lambda/"\[sqlescape(\%0)\]",strfirstof(%0,lit(>CYx95\%7D#\(oY\%f\{dloJ)),%b,\,)])
@set Scene System/W`ARGUMENTS`ARRAY=no_debug
&W`ARGUMENTS`ARRAY`SIGN Scene System=@
@set Scene System/W`ARGUMENTS`ARRAY`SIGN=no_debug
&W`ARGUMENTS`DATATABLE Scene System=`[v(data`sql`database)]`.`$[capstr(%0)]$`
@set Scene System/W`ARGUMENTS`DATATABLE=no_debug
&W`ARGUMENTS`DATATABLE`SIGN Scene System=d
@set Scene System/W`ARGUMENTS`DATATABLE`SIGN=no_debug
&W`ARGUMENTS`DIRECT Scene System=%0
@set Scene System/W`ARGUMENTS`DIRECT=no_debug
&W`ARGUMENTS`DIRECT`SIGN Scene System=a
@set Scene System/W`ARGUMENTS`DIRECT`SIGN=no_debug
&W`ARGUMENTS`GLOB2LIKE Scene System="[regeditall(sqlescape(%0),\[_\%\],\\$0,((?:\[^\\\\\]|^)(?:\\\\\\\\\\\\\\\\)*)(\[?\\*\]),$1[switch($2,\\?,_,\\*,\%)])]"
@set Scene System/W`ARGUMENTS`GLOB2LIKE=no_debug
&W`ARGUMENTS`GLOB2LIKE`SIGN Scene System=_
@set Scene System/W`ARGUMENTS`GLOB2LIKE`SIGN=no_debug
&W`ARGUMENTS`STANDARD Scene System=%b"[sqlescape(%0)]"
@set Scene System/W`ARGUMENTS`STANDARD=no_debug
&W`ARGUMENTS`STANDARD`SIGN Scene System=%b
@set Scene System/W`ARGUMENTS`STANDARD`SIGN=no_debug
&W`ARGUMENTS`TABLE Scene System=`[edit(%0,.,`.`)]`
@set Scene System/W`ARGUMENTS`TABLE=no_debug
&W`ARGUMENTS`TABLE`SIGN Scene System=t
@set Scene System/W`ARGUMENTS`TABLE`SIGN=no_debug
&W`ARGUMENTS`TRUEESCAPE Scene System='[sqlescape(%0)]'
@set Scene System/W`ARGUMENTS`TRUEESCAPE=no_debug
&W`ARGUMENTS`TRUEESCAPE`SIGN Scene System=!
@set Scene System/W`ARGUMENTS`TRUEESCAPE`SIGN=no_debug
&W`CREDITS Scene System=Original SQL wrapper created by Walker. Other credit goes to Mercutio for slight edits; inclusion of w`datatokens and expanded w`arguments.
@set Scene System/W`CREDITS=no_debug
&W`DATATOKENS Scene System=regeditalli(%0,`\\$([edit(u(w`fn`get`tablelist),%b,|)]|database)\\$`,`[switch($1,database,v(data`sql`database),u(w`fn`get`tablename,#$))]`)
@set Scene System/W`DATATOKENS=no_debug
&W`FN Scene System=General Functions
@set Scene System/W`FN=no_debug
&W`FN`GET Scene System=Gets information.
@set Scene System/W`FN`GET=no_debug
&W`FN`GET`ARGUMENTATTR Scene System=firstof(first(revwords(rest(revwords(grep(me,w`arguments`*`sign,decompose(%0)),`),`),`)),W`ARGUMENTS`STANDARD)
@set Scene System/W`FN`GET`ARGUMENTATTR=no_debug
&W`FN`GET`ARGUMENTLIST Scene System=iter(lattr(me/w`arguments`*`sign),u(%i0),,)
@set Scene System/W`FN`GET`ARGUMENTLIST=no_debug
&W`FN`GET`TABLELIST Scene System=iter(lattr(me/data`sql`table`),last(%i0,`))
@set Scene System/W`FN`GET`TABLELIST=no_debug
&W`FN`GET`TABLENAME Scene System=v(data`sql`table`%0)
@set Scene System/W`FN`GET`TABLENAME=no_debug
&W`FN`TRANSFORM Scene System=Transforms information. Like the w`datatokens, or the general 'prepare'.
@set Scene System/W`FN`TRANSFORM=no_debug
&W`FN`TRANSFORM`DATATOKENS Scene System=regeditalli(%0,`\\$([edit(u(w`fn`get`tablelist),%b,|)]|database)\\$`,`[switch($1,database,v(data`sql`database),u(w`fn`get`tablename,$1))]`)
@set Scene System/W`FN`TRANSFORM`DATATOKENS=no_debug
&W`FN`TRANSFORM`PREPARE Scene System=u(w`datatokens, regeditall(firstof(v(sql`[before(%0,:)]`[config(sql_platform)]),v(sql`[before(%0,:)])),(\[[u(w`fn`get`argumentlist)]\]?)\\?(?:<(\\d+)>)?,u(u(w`fn`get`argumentattr,$1),v(if(strlen($2),add($2,1),setr(i,inc(%qi)))))) )
@set Scene System/W`FN`TRANSFORM`PREPARE=no_debug
&W`MAPQUERY Scene System=localize(setq(i,1)[mapsql(%0,u(w`fn`transform`prepare,%1,%2,%3,%4,%5,%6,%7,%8,%9),firstof(elements(%1,2,:),%r),elements(%1,3,:))])
@set Scene System/W`MAPQUERY=no_debug
&W`PREPARE Scene System=localize(setq(i,0)[eval(me,w`fn`transform`prepare)])
@set Scene System/W`PREPARE=no_debug
&W`QUERY Scene System=setq(i,0)[sql(eval(me,w`fn`transform`prepare),firstof(elements(%0,2,:),%b),firstof(elements(%0,3,:),%b),s)]
@set Scene System/W`QUERY=no_debug
&W`UPDATE Scene System=localize(if(strlen(setr(0,eval(me,w`query))),%q0,firstof(sql(select last_insert_id(),,,s),%qs)))
@set Scene System/W`UPDATE=no_debug
&W`WRAPPER Scene System=SQL Wrapper. Detailed in the following CPO post: http://community.pennmush.org/story/sql-prepared-statements-mushcode. Editted by Mercutio to allow for expanded arguments (see 'arguments' argument) and the datatokens: `$DATABASE$` or `$TABLENAMEGOESHERE$`, as defined in data`sql`database and data`sql`table`tablenamegoeshere. It can handle a series of arguments that were not previously supported - and it is easy to add new ones. See the ARGUMENTS attribute tree. Sign-leafs for the marks, normal for the actualy replacement code.
@set Scene System/W`WRAPPER=no_debug
